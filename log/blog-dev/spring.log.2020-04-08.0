2020-04-08 11:26:33.625  INFO 25996 --- [restartedMain] com.hjf.blog.BlogApplication             : Starting BlogApplication on DESKTOP-9T76QD7 with PID 25996 (C:\workspace_idea\blog\target\classes started by hsj in C:\workspace_idea\blog)
2020-04-08 11:26:33.625 DEBUG 25996 --- [restartedMain] com.hjf.blog.BlogApplication             : Running with Spring Boot v2.2.5.RELEASE, Spring v5.2.4.RELEASE
2020-04-08 11:26:33.625  INFO 25996 --- [restartedMain] com.hjf.blog.BlogApplication             : The following profiles are active: dev
2020-04-08 11:26:33.719  INFO 25996 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-08 11:26:33.719  INFO 25996 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-08 11:26:36.344  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration$$EnhancerBySpringCGLIB$$7da19f09] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:36.532  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration$$EnhancerBySpringCGLIB$$8034ddae] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:36.594  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.hjf.blog.config.shiro.ShiroConfig$$EnhancerBySpringCGLIB$$71058cbd] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:36.813  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:36.828  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$9d5d1289] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:36.860  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:36.985  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.157  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'dataSource' of type [com.zaxxer.hikari.HikariDataSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.235  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.739  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.755  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.755  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.770  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [com.sun.proxy.$Proxy75] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.770  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userServiceImpl' of type [com.hjf.blog.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.770  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userRealm' of type [com.hjf.blog.config.shiro.UserRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.911  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'defaultWebSecurityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:37.958  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'authorizationAttributeSourceAdvisor' of type [org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:38.036  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'eventBus' of type [org.apache.shiro.event.support.DefaultEventBus] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:26:38.895  INFO 25996 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 80 (http)
2020-04-08 11:26:38.911  INFO 25996 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-04-08 11:26:38.911  INFO 25996 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-08 11:26:39.114  INFO 25996 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-04-08 11:26:39.114  INFO 25996 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 5395 ms
2020-04-08 11:26:40.316  INFO 25996 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-04-08 11:26:40.629  INFO 25996 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-04-08 11:26:42.606  INFO 25996 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-04-08 11:26:42.715  INFO 25996 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 80 (http) with context path ''
2020-04-08 11:26:42.715  INFO 25996 --- [restartedMain] com.hjf.blog.BlogApplication             : Started BlogApplication in 9.971 seconds (JVM running for 12.516)
2020-04-08 11:26:55.792  INFO 25996 --- [http-nio-80-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-08 11:26:55.793  INFO 25996 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-04-08 11:26:55.809  INFO 25996 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 15 ms
2020-04-08 11:26:55.856  INFO 25996 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.index', args=[]}
2020-04-08 11:26:55.864  INFO 25996 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : index
2020-04-08 11:26:57.302  INFO 25996 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 11:26:57.380  INFO 25996 --- [http-nio-80-exec-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-04-08 11:26:57.397  INFO 25996 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/indexData/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.findIndexData', args=[1]}
2020-04-08 11:26:57.776  INFO 25996 --- [http-nio-80-exec-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-04-08 11:26:57.936  INFO 25996 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 11:26:58.080  INFO 25996 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : {topTags=PageInfo{pageNum=1, pageSize=8, size=6, startRow=1, endRow=6, total=6, pages=1, list=Page{count=true, pageNum=1, pageSize=8, startRow=0, endRow=8, total=6, pages=1, reasonable=true, pageSizeZero=false}[Tag{id=1, tagName='编程', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=3, tagName='音乐', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=4, tagName='吉他', blogs=[Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=5, tagName='旅游', blogs=[Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=7, tagName='动漫', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=6, tagName='篮球', blogs=[Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, topBlogs=PageInfo{pageNum=1, pageSize=5, size=5, startRow=1, endRow=5, total=6, pages=2, list=Page{count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=6, pages=2, reasonable=true, pageSizeZero=false}[Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试测试测试'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=27, title='博客描述测试', content='# 五、SpringBoot与数据访问

## 1、JDBC

```xml
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
```



```yaml
spring:
  datasource:
    username: root
    password: 123456
    # mysql6版本以上要设置时区
    url: jdbc:mysql://192.168.15.22:3306/jdbc?serverTimezone=UTC&characterEncoding=UTF-8
    #springboot推荐用这个mysql驱动 com.mysql.cj.jdbc.Driver
    driver-class-name: com.mysql.jdbc.Driver 
```

效果：

​	默认是用com.zaxxer.hikari.HikariDataSource作为数据源；

​	数据源的相关配置都在DataSourceProperties里面；

自动配置原理：

org.springframework.boot.autoconfigure.jdbc：

1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；

2、SpringBoot默认可以支持；

```
org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、
```

3、自定义数据源类型

```java
/**
 * Generic DataSource configuration.
 */
@ConditionalOnMissingBean(DataSource.class)
@ConditionalOnProperty(name = "spring.datasource.type")
static class Generic {

   @Bean
   public DataSource dataSource(DataSourceProperties properties) {
       //使用DataSourceBuilder创建数据源，利用反射创建相应type的数据源，并且绑定相关属性
      return properties.initializeDataSourceBuilder().build();
   }

}
```

4、**DataSourceInitializer：ApplicationListener**；

​	作用：

​		1）、runSchemaScripts();运行建表语句；

​		2）、runDataScripts();运行插入数据的sql语句；

​		3)   、用SpringBoot初始化DDL和DML 要在配置文件中加这个

​						spring.datasource.initialization-mode:always

​						sql文件里的创建表语句必须在末尾加上';'，例如下面如果最后一个')'后不加';'是可以在Navicat里运行的，但是在Spring Boot的sql文件里必须加上';'，否则会报错

默认只需要将文件命名为：

```properties
schema-*.sql、data-*.sql
默认规则：schema.sql，schema-all.sql；
可以使用   
	schema:
      - classpath:department.sql #这个是建表的sql文件
      指定位置
```

5、操作数据库：**自动配置了JdbcTemplate操作数据库**

## 2、整合Druid数据源

1. 普通的方法换Druid数据池 不推荐使用，了解即可,一般用的多是第二种方法

   - ```xml
     <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
     <dependency>
         <groupId>com.alibaba</groupId>
         <artifactId>druid</artifactId>
         <version>1.1.20</version>
     </dependency>
     ```

  ```yaml
spring:
datasource:
username: root
password: admin
url: jdbc:mysql://localhost:3306/heima?serverTimezone=UTC&characterEncoding=UTF-8
driver-class-name: com.mysql.cj.jdbc.Driver
initialization-mode: always
# 数据源的类型换成Druid
type: com.alibaba.druid.pool.DruidDataSource
  ```

```java
导入druid数据源
@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druid(){
       return  new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
        Map<String,String> initParams = new HashMap<>();

        initParams.put("loginUsername","admin");
        initParams.put("loginPassword","123456");
        initParams.put("allow","");//默认就是允许所有访问
        initParams.put("deny","192.168.15.21");

        bean.setInitParameters(initParams);
        return bean;
    }


    //2、配置一个web监控的filter
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map<String,String> initParams = new HashMap<>();
        initParams.put("exclusions","*.js,*.css,/druid/*");

        bean.setInitParameters(initParams);

        bean.setUrlPatterns(Arrays.asList("/*"));

        return  bean;
    }
}

```

2. 新版SpringBoot以帮我们整合成一个starter:

​        导入的maven依赖

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.21</version>
</dependency>
```

​		 这样会有两个DataSource，我们要把Spring给我们自动配置的类排除掉

```java
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})//排除
public class SpringbootDataJdbcApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootDataJdbcApplication.class, args);
    }

}
```

  	druid的数据池的配置

```yaml
# druid配置
spring:
  datasource:  #数据源配置
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/heima?serverTimezone=UTC&characterEncoding=UTF-8
      username: root
      password: admin
      filters: stat,wall,logback #配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙
      stat-view-servlet: #监控页面配置
        enabled: true   #开启监控页面
        login-username: admin   #监控页面登录名
        login-password: admin   #监控页面密码
        allow:       #监控页面允许谁访问，不写默认所有
        deny:        #监控页面不允许谁访问
        url-pattern: /druid/*
```

3. druid的配置属性详情

```yaml
 # 连接池配置
    druid:
      # 初始化大小，最小，最大
      initial-size: 5
      min-idle: 5
      max-active: 20
      # 配置获取连接等待超时的时间
      max-wait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位毫秒
      time-between-eviction-runs-millis: 60000
      # 配置一个连接在池中最小生存时间
      min-evictable-idle-time-millis: 300000
      validation-query: SELECT 1 FROM sys_user
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      # 打开 PSCache，并且指定每个连接上 PSCache 的大小
      pool-prepared-statements: true
      max-pool-prepared-statement-per-connection-size: 20
      # 配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙
      filters: stat,wall,log4j
      # 通过 connection-properties 属性打开 mergeSql 功能；慢 SQL 记录
      connection-properties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
      # 配置 DruidStatFilter
      web-stat-filter:
        enabled: true
        url-pattern: /*
        exclusions: .js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*
      # 配置 DruidStatViewServlet
      stat-view-servlet:
        url-pattern: /druid/*
        # IP 白名单，没有配置或者为空，则允许所有访问
        allow: 127.0.0.1
        # IP 黑名单，若白名单也存在，则优先使用
        deny: 192.168.31.253
        # 禁用 HTML 中 Reset All 按钮
        reset-enable: false
        # 登录用户名/密码
        login-username: root
        login-password: 123
```

| 配置                          | 缺省值             | 说明                                                         |
| ----------------------------- | ------------------ | ------------------------------------------------------------ |
| name                          |                    | 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是："DataSource-" + System.identityHashCode(this).  另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 [详情-点此处](http://blog.csdn.net/lanmo555/article/details/41248763)。 |
| url                           |                    | 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2  oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto |
| username                      |                    | 连接数据库的用户名                                           |
| password                      |                    | 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter |
| driverClassName               | 根据url自动识别    | 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName |
| initialSize                   | 0                  | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |
| maxActive                     | 8                  | 最大连接池数量                                               |
| maxIdle                       | 8                  | 已经不再使用，配置了也没效果                                 |
| minIdle                       |                    | 最小连接池数量                                               |
| maxWait                       |                    | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |
| poolPreparedStatements        | false              | 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 |
| maxOpenPreparedStatements     | -1                 | 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 |
| validationQuery               |                    | 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 |
| validationQueryTimeout        |                    | 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 |
| testOnBorrow                  | true               | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |
| testOnReturn                  | false              | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |
| testWhileIdle                 | false              | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 |
| timeBetweenEvictionRunsMillis | 1分钟（1.0.14）    | 有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 |
| numTestsPerEvictionRun        |                    | 不再使用，一个DruidDataSource只支持一个EvictionRun           |
| minEvictableIdleTimeMillis    | 30分钟（1.0.14）   | 连接保持空闲而不被驱逐的最长时间                             |
| connectionInitSqls            |                    | 物理连接初始化的时候执行的sql                                |
| exceptionSorter               | 根据dbType自动识别 | 当数据库抛出一些不可恢复的异常时，抛弃连接                   |
| filters                       |                    | 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall |
| proxyFilters                  |                    | 类型是List<com.alibaba.druid.filter.Filter>，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 |

## 3、整合MyBatis


```xml
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.3.1</version>
		</dependency>
```

![](C:/Users/hsj/Desktop/Java/springboot/Spring Boot 笔记+课件/images/搜狗截图20180305194443.png)

步骤：

​	1）、配置数据源相关属性（见上一节Druid）

​	2）、给数据库建表

​	3）、创建JavaBean

### 	1）、注解版

```java
//指定这是一个操作数据库的mapper
@Mapper
public interface DepartmentMapper {

    @Select("select * from department where id=#{id}")
    public Department getDeptById(Integer id);

    @Delete("delete from department where id=#{id}")
    public int deleteDeptById(Integer id);

    //Options注解useGeneratedKeys自动生成key值返回给department对象.KeyProperty注解表示Key值是department对象的哪个属性
    @Options(useGeneratedKeys = true,keyProperty = "id")
    @Insert("insert into department(departmentName) values(#{departmentName})")
    public int insertDept(Department department);

    @Update("update department set departmentName=#{departmentName} where id=#{id}")
    public int updateDept(Department department);
}
```

问题：

自定义MyBatis的配置规则；给容器中添加一个自定义的ConfigurationCustomizer；

```java
@org.springframework.context.annotation.Configuration
public class MyBatisConfig {

    @Bean
    public ConfigurationCustomizer configurationCustomizer(){
        return new ConfigurationCustomizer(){

            @Override
            public void customize(Configuration configuration) {
                //设置驼峰映射开启
                configuration.setMapUnderscoreToCamelCase(true);
            }
        };
    }
}
```



```java
使用MapperScan批量扫描所有的Mapper接口；
@MapperScan(value = "com.atguigu.springboot.mapper")
@SpringBootApplication
public class SpringBoot06DataMybatisApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);
	}
}
```

### 2）、配置文件版

先要给**Mapper类中添加@Mapper接口**或者在**配置类中添加@MapperScan(value = "com.atguigu.springboot.mapper")**扫描，把Mapper对象装入到SpringBoot的容器中

```yaml
mybatis:
  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置
  mapper-locations: classpath:mybatis/mapper/*.xml  指定sql映射文件的位置
#加了这两句就不需要Mapper接口和sql映射文件放到同一个目录了
```

更多使用参照

http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/

### 3) 、MyBatis开启事务

**使用 @Transactional 注解开启事务**

　　@Transactional标记在方法上，捕获异常就rollback，否则就commit。自动提交事务

**@Transactional注解只能在抛出RuntimeException或者Error时才会触发事务的回滚，常见的非RuntimeException是不会触发事务的回滚的。但是我们平时做业务处理时，需要捕获异常，所以可以手动抛出RuntimeException异常或者添加rollbackFor = Exception.class(也可以指定相应异常)**

**主配置类中开启注解事务管理**

```java
@EnableTransactionManagement // 开启注解事务管理
@SpringBootApplication
public class BlogApplication {

    public static void main(String[] args) {
        SpringApplication.run(BlogApplication.class, args);
    }

}
```

```java
/**
     * @Transactional 的参数
     * value                   |String                        | 可选的限定描述符，指定使用的事务管理器
     * propagation             |Enum: Propagation             | 可选的事务传播行为设置
     * isolation               |Enum: Isolation               | 可选的事务隔离级别设置
     * readOnly                |boolean                       | 读写或只读事务，默认读写
     * timeout                 |int (seconds)                 | 事务超时时间设置
     * rollbackFor             |Class<? extends Throwable>[]  | 导致事务回滚的异常类数组
     * rollbackForClassName    |String[]                      | 导致事务回滚的异常类名字数组
     * noRollbackFor           |Class<? extends Throwable>[]  | 不会导致事务回滚的异常类数组
     * noRollbackForClassName  |String[]                      | 不会导致事务回滚的异常类名字数组
     */
    @Transactional(rollbackFor = Exception.class)
    public void testTransactional() {
            // dosomething..
    }
```

**使用Springboot的事务管理**

​		如果想使用手动提交事务，可以使用该方法。需要注入两个Bean，最后记得提交事务

```java
@Autowired
    private DataSourceTransactionManager dataSourceTransactionManager;
    
    @Autowired
    private TransactionDefinition transactionDefinition;

　　public void testHandleCommitTS(boolean exceptionFlag) {
//        DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();
//        transactionDefinition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        // 开启事务
        TransactionStatus transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);
        try {
            // dosomething
            // 提交事务
            dataSourceTransactionManager.commit(transactionStatus);
        } catch (Exception e) {
            e.printStackTrace();
            // 回滚事务
            dataSourceTransactionManager.rollback(transactionStatus);
        }
    }
```

**@Transactional 注解不生效原因**

​	1、检查你的方法是不是public的。@Transactional注解只能应用到public可见度的方法上，如果应用在protected、private或者package可见度的方法上，也不会报错，不过事务设置不会起作用。

2、检查你的异常类型是不是unchecked异常。默认情况下，Spring会对unchecked异常进行事务回滚，如果是checked异常则不回滚。如空指针异常、算术异常等，会被回滚；文件读写、网络出问题，spring就没法回滚了。如果你想check异常也回滚怎么办，注解上面写明异常类型即可：

```java
@Transactional(rollbackFor = Exception.class)
```

类型的还有norollbackFor，自定义不回滚的异常。

3、是否在service中进行了try...catch的操作，由于已经被捕获异常，故事务也不会回滚。如果非要在service中try...catch异常，又想要事务回滚，可在catch块中抛出运行时异常：

```java
try{
    ....  
}catch(Exception e){
    logger.error("",e);
    throw new RuntimeException;
}
```

这种方法有个不足之处，就是不能在catch块中存在return子句，若想捕获异常时回滚事务，同时返回提示信息，可以使用手动回滚：

```java
try{
    ...
}catch(Exception e){
    logger.error("",e);
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    return ERROR_MESSAGE;
}
```

PS:另外说明一下，在controller层捕获了service层的异常，事务还会回滚吗？答案是会的，只要你service层抛出了异常，并且你加的事务可以处理这个异常，也就是rollbackFor = Exception.class这个符合你抛出的异常，不管外面有没有捕获都可以回滚。

**注意**

**注解自动事务和手动事务不能一起用**

### 4) 、分页插件PageHelper

pom.xml:

```xml
<!-- 引入分页插件 -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.2.13</version>
</dependency>
```

application.yml:

```yaml
# 分页配置
pagehelper:
  helper-dialect: mysql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql
```

java:

```java
/**
 * 分页查询Type
 * @param start
 * @param count
 * @return
 */
@Override
public PageInfo<Type> listType(int start, int count) {
    PageHelper.startPage(start, count);
    List<Type> types = typeDao.findAllType();
    PageInfo<Type> pageInfo = new PageInfo<>(types);
    return pageInfo;
}
```

PageInfo返回json的数据解释

```java
当前页 
private int pageNum;
每页的数量  
private int pageSize;  
当前页的数量  
private int size;  
//由于startRow和endRow不常用，这里说个具体的用法  
//可以在页面中"显示startRow到endRow 共size条数据"  

当前页面第一个元素在数据库中的行号  
private int startRow;  
当前页面最后一个元素在数据库中的行号  
private int endRow;  
总记录数  
private long total;  
总页数  
private int pages;  
结果集  
private List<T> list;  

第一页  
private int firstPage;  
前一页  
private int prePage;  

是否为第一页  
private boolean isFirstPage = false;  
是否为最后一页  
private boolean isLastPage = false;  
是否有前一页  
private boolean hasPreviousPage = false;  
是否有下一页  
private boolean hasNextPage = false;  
导航页码数  
private int navigatePages;  
所有导航页号  
private int[] navigatepageNums;  
后台分页
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Mon Apr 02 22:16:00 CST 2018, updateTime=Sun Apr 05 23:17:55 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试测试测试'}], prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=8, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]}, blogs=PageInfo{pageNum=1, pageSize=7, size=6, startRow=1, endRow=6, total=6, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=6, pages=1, reasonable=true, pageSizeZero=false}[Blog{id=20, title='测试1', content='# 一、SpringBoot入门

## 1.回顾Spring

### 1.1、什么是Spring

Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。

**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**



### 1.2、Spring是如何简化Java开发的

为了降低Java开发的复杂性，Spring采用了以下4种关键策略：

1、基于POJO的轻量级和最小侵入性编程；

2、通过IOC，依赖注入（DI）和面向接口实现松耦合；

3、基于切面（AOP）和惯例进行声明式编程；

4、通过切面和模版减少样式代码；



### 1.3、什么是SpringBoot

学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤； 后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；不知道你们有没经历过框架不断的演进，然后自己开发项目所有的技术也再不断的变化、改造，反正我是都经历过了，哈哈。言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can "just run"，能迅速的开发web应用，几行代码开发一个http接口。

所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。

是的这就是Java企业级应用->J2EE->spring->springboot的过程。

随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；

Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，

简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。

Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。

**Spring Boot的主要优点：**

- 为所有Spring开发者更快的入门
- **开箱即用**，提供各种默认配置来简化项目配置
- 内嵌式容器简化Web项目
- 没有冗余代码生成和XML配置的要求', firstPicture='/images/avatar.jpg', flag='原创', views=58, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Sat Apr 01 21:30:43 CST 2017, updateTime=Sun Apr 02 22:13:27 CST 2017, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试1的说明'}, Blog{id=27, title='博客描述测试', content='# 五、SpringBoot与数据访问

## 1、JDBC

```xml
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
```



```yaml
spring:
  datasource:
    username: root
    password: 123456
    # mysql6版本以上要设置时区
    url: jdbc:mysql://192.168.15.22:3306/jdbc?serverTimezone=UTC&characterEncoding=UTF-8
    #springboot推荐用这个mysql驱动 com.mysql.cj.jdbc.Driver
    driver-class-name: com.mysql.jdbc.Driver 
```

效果：

​	默认是用com.zaxxer.hikari.HikariDataSource作为数据源；

​	数据源的相关配置都在DataSourceProperties里面；

自动配置原理：

org.springframework.boot.autoconfigure.jdbc：

1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；

2、SpringBoot默认可以支持；

```
org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、
```

3、自定义数据源类型

```java
/**
 * Generic DataSource configuration.
 */
@ConditionalOnMissingBean(DataSource.class)
@ConditionalOnProperty(name = "spring.datasource.type")
static class Generic {

   @Bean
   public DataSource dataSource(DataSourceProperties properties) {
       //使用DataSourceBuilder创建数据源，利用反射创建相应type的数据源，并且绑定相关属性
      return properties.initializeDataSourceBuilder().build();
   }

}
```

4、**DataSourceInitializer：ApplicationListener**；

​	作用：

​		1）、runSchemaScripts();运行建表语句；

​		2）、runDataScripts();运行插入数据的sql语句；

​		3)   、用SpringBoot初始化DDL和DML 要在配置文件中加这个

​						spring.datasource.initialization-mode:always

​						sql文件里的创建表语句必须在末尾加上';'，例如下面如果最后一个')'后不加';'是可以在Navicat里运行的，但是在Spring Boot的sql文件里必须加上';'，否则会报错

默认只需要将文件命名为：

```properties
schema-*.sql、data-*.sql
默认规则：schema.sql，schema-all.sql；
可以使用   
	schema:
      - classpath:department.sql #这个是建表的sql文件
      指定位置
```

5、操作数据库：**自动配置了JdbcTemplate操作数据库**

## 2、整合Druid数据源

1. 普通的方法换Druid数据池 不推荐使用，了解即可,一般用的多是第二种方法

   - ```xml
     <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
     <dependency>
         <groupId>com.alibaba</groupId>
         <artifactId>druid</artifactId>
         <version>1.1.20</version>
     </dependency>
     ```

  ```yaml
spring:
datasource:
username: root
password: admin
url: jdbc:mysql://localhost:3306/heima?serverTimezone=UTC&characterEncoding=UTF-8
driver-class-name: com.mysql.cj.jdbc.Driver
initialization-mode: always
# 数据源的类型换成Druid
type: com.alibaba.druid.pool.DruidDataSource
  ```

```java
导入druid数据源
@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druid(){
       return  new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
        Map<String,String> initParams = new HashMap<>();

        initParams.put("loginUsername","admin");
        initParams.put("loginPassword","123456");
        initParams.put("allow","");//默认就是允许所有访问
        initParams.put("deny","192.168.15.21");

        bean.setInitParameters(initParams);
        return bean;
    }


    //2、配置一个web监控的filter
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map<String,String> initParams = new HashMap<>();
        initParams.put("exclusions","*.js,*.css,/druid/*");

        bean.setInitParameters(initParams);

        bean.setUrlPatterns(Arrays.asList("/*"));

        return  bean;
    }
}

```

2. 新版SpringBoot以帮我们整合成一个starter:

​        导入的maven依赖

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.21</version>
</dependency>
```

​		 这样会有两个DataSource，我们要把Spring给我们自动配置的类排除掉

```java
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})//排除
public class SpringbootDataJdbcApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootDataJdbcApplication.class, args);
    }

}
```

  	druid的数据池的配置

```yaml
# druid配置
spring:
  datasource:  #数据源配置
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/heima?serverTimezone=UTC&characterEncoding=UTF-8
      username: root
      password: admin
      filters: stat,wall,logback #配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙
      stat-view-servlet: #监控页面配置
        enabled: true   #开启监控页面
        login-username: admin   #监控页面登录名
        login-password: admin   #监控页面密码
        allow:       #监控页面允许谁访问，不写默认所有
        deny:        #监控页面不允许谁访问
        url-pattern: /druid/*
```

3. druid的配置属性详情

```yaml
 # 连接池配置
    druid:
      # 初始化大小，最小，最大
      initial-size: 5
      min-idle: 5
      max-active: 20
      # 配置获取连接等待超时的时间
      max-wait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位毫秒
      time-between-eviction-runs-millis: 60000
      # 配置一个连接在池中最小生存时间
      min-evictable-idle-time-millis: 300000
      validation-query: SELECT 1 FROM sys_user
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      # 打开 PSCache，并且指定每个连接上 PSCache 的大小
      pool-prepared-statements: true
      max-pool-prepared-statement-per-connection-size: 20
      # 配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙
      filters: stat,wall,log4j
      # 通过 connection-properties 属性打开 mergeSql 功能；慢 SQL 记录
      connection-properties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
      # 配置 DruidStatFilter
      web-stat-filter:
        enabled: true
        url-pattern: /*
        exclusions: .js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*
      # 配置 DruidStatViewServlet
      stat-view-servlet:
        url-pattern: /druid/*
        # IP 白名单，没有配置或者为空，则允许所有访问
        allow: 127.0.0.1
        # IP 黑名单，若白名单也存在，则优先使用
        deny: 192.168.31.253
        # 禁用 HTML 中 Reset All 按钮
        reset-enable: false
        # 登录用户名/密码
        login-username: root
        login-password: 123
```

| 配置                          | 缺省值             | 说明                                                         |
| ----------------------------- | ------------------ | ------------------------------------------------------------ |
| name                          |                    | 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是："DataSource-" + System.identityHashCode(this).  另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 [详情-点此处](http://blog.csdn.net/lanmo555/article/details/41248763)。 |
| url                           |                    | 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2  oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto |
| username                      |                    | 连接数据库的用户名                                           |
| password                      |                    | 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter |
| driverClassName               | 根据url自动识别    | 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName |
| initialSize                   | 0                  | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |
| maxActive                     | 8                  | 最大连接池数量                                               |
| maxIdle                       | 8                  | 已经不再使用，配置了也没效果                                 |
| minIdle                       |                    | 最小连接池数量                                               |
| maxWait                       |                    | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |
| poolPreparedStatements        | false              | 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 |
| maxOpenPreparedStatements     | -1                 | 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 |
| validationQuery               |                    | 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 |
| validationQueryTimeout        |                    | 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 |
| testOnBorrow                  | true               | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |
| testOnReturn                  | false              | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |
| testWhileIdle                 | false              | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 |
| timeBetweenEvictionRunsMillis | 1分钟（1.0.14）    | 有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 |
| numTestsPerEvictionRun        |                    | 不再使用，一个DruidDataSource只支持一个EvictionRun           |
| minEvictableIdleTimeMillis    | 30分钟（1.0.14）   | 连接保持空闲而不被驱逐的最长时间                             |
| connectionInitSqls            |                    | 物理连接初始化的时候执行的sql                                |
| exceptionSorter               | 根据dbType自动识别 | 当数据库抛出一些不可恢复的异常时，抛弃连接                   |
| filters                       |                    | 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall |
| proxyFilters                  |                    | 类型是List<com.alibaba.druid.filter.Filter>，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 |

## 3、整合MyBatis


```xml
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.3.1</version>
		</dependency>
```

![](C:/Users/hsj/Desktop/Java/springboot/Spring Boot 笔记+课件/images/搜狗截图20180305194443.png)

步骤：

​	1）、配置数据源相关属性（见上一节Druid）

​	2）、给数据库建表

​	3）、创建JavaBean

### 	1）、注解版

```java
//指定这是一个操作数据库的mapper
@Mapper
public interface DepartmentMapper {

    @Select("select * from department where id=#{id}")
    public Department getDeptById(Integer id);

    @Delete("delete from department where id=#{id}")
    public int deleteDeptById(Integer id);

    //Options注解useGeneratedKeys自动生成key值返回给department对象.KeyProperty注解表示Key值是department对象的哪个属性
    @Options(useGeneratedKeys = true,keyProperty = "id")
    @Insert("insert into department(departmentName) values(#{departmentName})")
    public int insertDept(Department department);

    @Update("update department set departmentName=#{departmentName} where id=#{id}")
    public int updateDept(Department department);
}
```

问题：

自定义MyBatis的配置规则；给容器中添加一个自定义的ConfigurationCustomizer；

```java
@org.springframework.context.annotation.Configuration
public class MyBatisConfig {

    @Bean
    public ConfigurationCustomizer configurationCustomizer(){
        return new ConfigurationCustomizer(){

            @Override
            public void customize(Configuration configuration) {
                //设置驼峰映射开启
                configuration.setMapUnderscoreToCamelCase(true);
            }
        };
    }
}
```



```java
使用MapperScan批量扫描所有的Mapper接口；
@MapperScan(value = "com.atguigu.springboot.mapper")
@SpringBootApplication
public class SpringBoot06DataMybatisApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);
	}
}
```

### 2）、配置文件版

先要给**Mapper类中添加@Mapper接口**或者在**配置类中添加@MapperScan(value = "com.atguigu.springboot.mapper")**扫描，把Mapper对象装入到SpringBoot的容器中

```yaml
mybatis:
  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置
  mapper-locations: classpath:mybatis/mapper/*.xml  指定sql映射文件的位置
#加了这两句就不需要Mapper接口和sql映射文件放到同一个目录了
```

更多使用参照

http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/

### 3) 、MyBatis开启事务

**使用 @Transactional 注解开启事务**

　　@Transactional标记在方法上，捕获异常就rollback，否则就commit。自动提交事务

**@Transactional注解只能在抛出RuntimeException或者Error时才会触发事务的回滚，常见的非RuntimeException是不会触发事务的回滚的。但是我们平时做业务处理时，需要捕获异常，所以可以手动抛出RuntimeException异常或者添加rollbackFor = Exception.class(也可以指定相应异常)**

**主配置类中开启注解事务管理**

```java
@EnableTransactionManagement // 开启注解事务管理
@SpringBootApplication
public class BlogApplication {

    public static void main(String[] args) {
        SpringApplication.run(BlogApplication.class, args);
    }

}
```

```java
/**
     * @Transactional 的参数
     * value                   |String                        | 可选的限定描述符，指定使用的事务管理器
     * propagation             |Enum: Propagation             | 可选的事务传播行为设置
     * isolation               |Enum: Isolation               | 可选的事务隔离级别设置
     * readOnly                |boolean                       | 读写或只读事务，默认读写
     * timeout                 |int (seconds)                 | 事务超时时间设置
     * rollbackFor             |Class<? extends Throwable>[]  | 导致事务回滚的异常类数组
     * rollbackForClassName    |String[]                      | 导致事务回滚的异常类名字数组
     * noRollbackFor           |Class<? extends Throwable>[]  | 不会导致事务回滚的异常类数组
     * noRollbackForClassName  |String[]                      | 不会导致事务回滚的异常类名字数组
     */
    @Transactional(rollbackFor = Exception.class)
    public void testTransactional() {
            // dosomething..
    }
```

**使用Springboot的事务管理**

​		如果想使用手动提交事务，可以使用该方法。需要注入两个Bean，最后记得提交事务

```java
@Autowired
    private DataSourceTransactionManager dataSourceTransactionManager;
    
    @Autowired
    private TransactionDefinition transactionDefinition;

　　public void testHandleCommitTS(boolean exceptionFlag) {
//        DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();
//        transactionDefinition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        // 开启事务
        TransactionStatus transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);
        try {
            // dosomething
            // 提交事务
            dataSourceTransactionManager.commit(transactionStatus);
        } catch (Exception e) {
            e.printStackTrace();
            // 回滚事务
            dataSourceTransactionManager.rollback(transactionStatus);
        }
    }
```

**@Transactional 注解不生效原因**

​	1、检查你的方法是不是public的。@Transactional注解只能应用到public可见度的方法上，如果应用在protected、private或者package可见度的方法上，也不会报错，不过事务设置不会起作用。

2、检查你的异常类型是不是unchecked异常。默认情况下，Spring会对unchecked异常进行事务回滚，如果是checked异常则不回滚。如空指针异常、算术异常等，会被回滚；文件读写、网络出问题，spring就没法回滚了。如果你想check异常也回滚怎么办，注解上面写明异常类型即可：

```java
@Transactional(rollbackFor = Exception.class)
```

类型的还有norollbackFor，自定义不回滚的异常。

3、是否在service中进行了try...catch的操作，由于已经被捕获异常，故事务也不会回滚。如果非要在service中try...catch异常，又想要事务回滚，可在catch块中抛出运行时异常：

```java
try{
    ....  
}catch(Exception e){
    logger.error("",e);
    throw new RuntimeException;
}
```

这种方法有个不足之处，就是不能在catch块中存在return子句，若想捕获异常时回滚事务，同时返回提示信息，可以使用手动回滚：

```java
try{
    ...
}catch(Exception e){
    logger.error("",e);
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    return ERROR_MESSAGE;
}
```

PS:另外说明一下，在controller层捕获了service层的异常，事务还会回滚吗？答案是会的，只要你service层抛出了异常，并且你加的事务可以处理这个异常，也就是rollbackFor = Exception.class这个符合你抛出的异常，不管外面有没有捕获都可以回滚。

**注意**

**注解自动事务和手动事务不能一起用**

### 4) 、分页插件PageHelper

pom.xml:

```xml
<!-- 引入分页插件 -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.2.13</version>
</dependency>
```

application.yml:

```yaml
# 分页配置
pagehelper:
  helper-dialect: mysql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql
```

java:

```java
/**
 * 分页查询Type
 * @param start
 * @param count
 * @return
 */
@Override
public PageInfo<Type> listType(int start, int count) {
    PageHelper.startPage(start, count);
    List<Type> types = typeDao.findAllType();
    PageInfo<Type> pageInfo = new PageInfo<>(types);
    return pageInfo;
}
```

PageInfo返回json的数据解释

```java
当前页 
private int pageNum;
每页的数量  
private int pageSize;  
当前页的数量  
private int size;  
//由于startRow和endRow不常用，这里说个具体的用法  
//可以在页面中"显示startRow到endRow 共size条数据"  

当前页面第一个元素在数据库中的行号  
private int startRow;  
当前页面最后一个元素在数据库中的行号  
private int endRow;  
总记录数  
private long total;  
总页数  
private int pages;  
结果集  
private List<T> list;  

第一页  
private int firstPage;  
前一页  
private int prePage;  

是否为第一页  
private boolean isFirstPage = false;  
是否为最后一页  
private boolean isLastPage = false;  
是否有前一页  
private boolean hasPreviousPage = false;  
是否有下一页  
private boolean hasNextPage = false;  
导航页码数  
private int navigatePages;  
所有导航页号  
private int[] navigatepageNums;  
后台分页
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Mon Apr 02 22:16:00 CST 2018, updateTime=Sun Apr 05 23:17:55 CST 2020, type=Type{id=1, typeName='Java', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试测试测试'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=Type{id=1, typeName='Java', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试测试测试'}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, totalBlogsCount=6, topTypes=PageInfo{pageNum=1, pageSize=7, size=3, startRow=1, endRow=3, total=6, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=6, pages=1, reasonable=true, pageSizeZero=false}[Type{id=1, typeName='Java', blogs=[Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=38, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=6, typeName='SpringBoot', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=7, typeName='Mybatis', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}}
2020-04-08 11:27:50.553  WARN 25996 --- [http-nio-80-exec-5] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [569] milliseconds.
2020-04-08 11:27:50.556  INFO 25996 --- [http-nio-80-exec-5] c.h.b.controller.admin.LoginController   : 登陆成功
2020-04-08 11:27:51.212  INFO 25996 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 11:27:51.217  INFO 25996 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 11:27:53.114  INFO 25996 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 11:27:53.119  INFO 25996 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 11:27:54.469  INFO 25996 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 11:27:54.474  INFO 25996 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 11:27:59.834  INFO 25996 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/file/upload', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.FileController.demo', args=[org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@4d7bc8c1, org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@e55b8da]}
2020-04-08 11:27:59.849  INFO 25996 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Result : {success=1, message=上传成功！, url=/image/rotPhoto/bg1.jpg}
2020-04-08 11:29:16.717  INFO 25996 --- [Thread-5] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2020-04-08 11:29:16.721  INFO 25996 --- [Thread-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2020-04-08 11:29:16.740  INFO 25996 --- [Thread-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2020-04-08 11:29:18.086  INFO 25996 --- [restartedMain] com.hjf.blog.BlogApplication             : Starting BlogApplication on DESKTOP-9T76QD7 with PID 25996 (C:\workspace_idea\blog\target\classes started by hsj in C:\workspace_idea\blog)
2020-04-08 11:29:18.086 DEBUG 25996 --- [restartedMain] com.hjf.blog.BlogApplication             : Running with Spring Boot v2.2.5.RELEASE, Spring v5.2.4.RELEASE
2020-04-08 11:29:18.102  INFO 25996 --- [restartedMain] com.hjf.blog.BlogApplication             : The following profiles are active: dev
2020-04-08 11:29:18.915  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration$$EnhancerBySpringCGLIB$$7da19f09] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:18.932  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration$$EnhancerBySpringCGLIB$$8034ddae] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:18.939  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.hjf.blog.config.shiro.ShiroConfig$$EnhancerBySpringCGLIB$$71058cbd] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:18.956  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:18.964  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$9d5d1289] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:18.972  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:18.982  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:18.994  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'dataSource' of type [com.zaxxer.hikari.HikariDataSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.007  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.106  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.116  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.123  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.130  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [com.sun.proxy.$Proxy123] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.134  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userServiceImpl' of type [com.hjf.blog.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.139  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userRealm' of type [com.hjf.blog.config.shiro.UserRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.160  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'defaultWebSecurityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.202  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'authorizationAttributeSourceAdvisor' of type [org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.228  INFO 25996 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'eventBus' of type [org.apache.shiro.event.support.DefaultEventBus] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:29:19.452  INFO 25996 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 80 (http)
2020-04-08 11:29:19.472  INFO 25996 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-04-08 11:29:19.475  INFO 25996 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-08 11:29:19.637  INFO 25996 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-04-08 11:29:19.639  INFO 25996 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1490 ms
2020-04-08 11:29:20.754  INFO 25996 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-04-08 11:29:20.906  INFO 25996 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-04-08 11:29:22.909  INFO 25996 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-04-08 11:29:22.985  INFO 25996 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 80 (http) with context path ''
2020-04-08 11:29:22.987  INFO 25996 --- [restartedMain] com.hjf.blog.BlogApplication             : Started BlogApplication in 5.036 seconds (JVM running for 172.777)
2020-04-08 11:29:22.997  INFO 25996 --- [restartedMain] .ConditionEvaluationDeltaLoggingListener : Condition evaluation unchanged
2020-04-08 11:29:54.463  INFO 25996 --- [http-nio-80-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-08 11:29:54.469  INFO 25996 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-04-08 11:29:54.481  INFO 25996 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 12 ms
2020-04-08 11:29:55.856  INFO 25996 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 11:29:55.867  INFO 25996 --- [http-nio-80-exec-4] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...
2020-04-08 11:29:55.877  INFO 25996 --- [http-nio-80-exec-4] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.
2020-04-08 11:29:55.880  INFO 25996 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 11:30:01.330  INFO 25996 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/file/upload', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.FileController.demo', args=[org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@559582a4, org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@34363fd1]}
2020-04-08 11:30:01.346  INFO 25996 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Result : {success=1, message=上传成功！, url=/image/rotPhoto/bg1.jpg}
2020-04-08 11:31:44.687  INFO 22020 --- [restartedMain] com.hjf.blog.BlogApplication             : Starting BlogApplication on DESKTOP-9T76QD7 with PID 22020 (C:\workspace_idea\blog\target\classes started by hsj in C:\workspace_idea\blog)
2020-04-08 11:31:44.703 DEBUG 22020 --- [restartedMain] com.hjf.blog.BlogApplication             : Running with Spring Boot v2.2.5.RELEASE, Spring v5.2.4.RELEASE
2020-04-08 11:31:44.703  INFO 22020 --- [restartedMain] com.hjf.blog.BlogApplication             : The following profiles are active: dev
2020-04-08 11:31:44.781  INFO 22020 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-08 11:31:44.781  INFO 22020 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-08 11:31:46.748  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration$$EnhancerBySpringCGLIB$$b41bc114] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:46.854  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration$$EnhancerBySpringCGLIB$$b6aeffb9] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:46.892  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.hjf.blog.config.shiro.ShiroConfig$$EnhancerBySpringCGLIB$$a77faec8] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.072  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.091  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$d3d73494] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.109  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.120  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.159  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'dataSource' of type [com.zaxxer.hikari.HikariDataSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.194  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.651  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.668  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.692  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.705  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [com.sun.proxy.$Proxy75] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.729  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userServiceImpl' of type [com.hjf.blog.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.730  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userRealm' of type [com.hjf.blog.config.shiro.UserRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.888  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'defaultWebSecurityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:47.951  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'authorizationAttributeSourceAdvisor' of type [org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:48.071  INFO 22020 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'eventBus' of type [org.apache.shiro.event.support.DefaultEventBus] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 11:31:48.745  INFO 22020 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 80 (http)
2020-04-08 11:31:48.761  INFO 22020 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-04-08 11:31:48.761  INFO 22020 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-08 11:31:48.901  INFO 22020 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-04-08 11:31:48.901  INFO 22020 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 4120 ms
2020-04-08 11:31:49.526  INFO 22020 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-04-08 11:31:49.686  INFO 22020 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-04-08 11:31:50.485  INFO 22020 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-04-08 11:31:50.543  INFO 22020 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 80 (http) with context path ''
2020-04-08 11:31:50.543  INFO 22020 --- [restartedMain] com.hjf.blog.BlogApplication             : Started BlogApplication in 6.87 seconds (JVM running for 9.159)
2020-04-08 11:31:54.820  INFO 22020 --- [http-nio-80-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-08 11:31:54.821  INFO 22020 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-04-08 11:31:54.844  INFO 22020 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 23 ms
2020-04-08 11:31:55.738  WARN 22020 --- [http-nio-80-exec-1] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [839] milliseconds.
2020-04-08 11:32:03.841  INFO 22020 --- [http-nio-80-exec-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-04-08 11:32:03.982  INFO 22020 --- [http-nio-80-exec-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-04-08 11:32:04.045  INFO 22020 --- [http-nio-80-exec-5] c.h.b.controller.admin.LoginController   : 登陆成功
2020-04-08 11:32:04.587  INFO 22020 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 11:32:04.616  INFO 22020 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 11:32:06.146  INFO 22020 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 11:32:06.152  INFO 22020 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 11:32:08.417  INFO 22020 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 11:32:08.423  INFO 22020 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 11:32:13.123  INFO 22020 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/file/upload', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.FileController.demo', args=[org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@301aca7, org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@3d0b98f1]}
2020-04-08 11:32:13.137  INFO 22020 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : {success=1, message=上传成功！, url=/image/rotPhoto/bg1.jpg}
2020-04-08 11:32:22.331  INFO 22020 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2020-04-08 11:32:22.331  INFO 22020 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2020-04-08 11:32:22.347  INFO 22020 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2020-04-08 15:08:17.064  INFO 19084 --- [restartedMain] com.hjf.blog.BlogApplication             : Starting BlogApplication on DESKTOP-9T76QD7 with PID 19084 (C:\workspace_idea\blog\target\classes started by hsj in C:\workspace_idea\blog)
2020-04-08 15:08:17.075 DEBUG 19084 --- [restartedMain] com.hjf.blog.BlogApplication             : Running with Spring Boot v2.2.5.RELEASE, Spring v5.2.4.RELEASE
2020-04-08 15:08:17.075  INFO 19084 --- [restartedMain] com.hjf.blog.BlogApplication             : The following profiles are active: dev
2020-04-08 15:08:17.179  INFO 19084 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-08 15:08:17.179  INFO 19084 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-08 15:08:19.187  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration$$EnhancerBySpringCGLIB$$5c92bd7a] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.315  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration$$EnhancerBySpringCGLIB$$5f25fc1f] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.371  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.hjf.blog.config.shiro.ShiroConfig$$EnhancerBySpringCGLIB$$4ff6ab2e] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.525  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.535  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$7c4e30fa] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.544  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.551  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.584  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'dataSource' of type [com.zaxxer.hikari.HikariDataSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.609  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.981  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.991  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:19.997  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:20.004  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [com.sun.proxy.$Proxy75] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:20.009  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userServiceImpl' of type [com.hjf.blog.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:20.013  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userRealm' of type [com.hjf.blog.config.shiro.UserRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:20.124  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'defaultWebSecurityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:20.150  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'authorizationAttributeSourceAdvisor' of type [org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:20.185  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'eventBus' of type [org.apache.shiro.event.support.DefaultEventBus] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:08:20.589  INFO 19084 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 80 (http)
2020-04-08 15:08:20.599  INFO 19084 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-04-08 15:08:20.600  INFO 19084 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-08 15:08:20.737  INFO 19084 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-04-08 15:08:20.738  INFO 19084 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 3559 ms
2020-04-08 15:08:21.426  INFO 19084 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-04-08 15:08:21.547  INFO 19084 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-04-08 15:08:22.318  INFO 19084 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-04-08 15:08:22.401  INFO 19084 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 80 (http) with context path ''
2020-04-08 15:08:22.406  INFO 19084 --- [restartedMain] com.hjf.blog.BlogApplication             : Started BlogApplication in 6.415 seconds (JVM running for 8.645)
2020-04-08 15:08:39.893  INFO 19084 --- [http-nio-80-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-08 15:08:39.894  INFO 19084 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-04-08 15:08:39.910  INFO 19084 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 15 ms
2020-04-08 15:08:48.472  WARN 19084 --- [http-nio-80-exec-3] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [618] milliseconds.
2020-04-08 15:08:48.502  INFO 19084 --- [http-nio-80-exec-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-04-08 15:08:48.670  INFO 19084 --- [http-nio-80-exec-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-04-08 15:08:48.768  INFO 19084 --- [http-nio-80-exec-3] c.h.b.controller.admin.LoginController   : 登陆成功
2020-04-08 15:08:49.512  INFO 19084 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:08:49.550  INFO 19084 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:08:51.622  INFO 19084 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:08:51.627  INFO 19084 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:08:56.015 ERROR 19084 --- [http-nio-80-exec-10] c.h.b.h.ControllerExceptionHandler       : Request URL : http://localhost/admin/tags/delete/null,Exception : {}

org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: "null"
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:133)
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61)
	at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108)
	at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
	at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
	at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
	at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
	at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:387)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:835)
Caused by: java.lang.NumberFormatException: For input string: "null"
	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68)
	at java.base/java.lang.Long.parseLong(Long.java:699)
	at java.base/java.lang.Long.valueOf(Long.java:1151)
	at org.springframework.util.NumberUtils.parseNumber(NumberUtils.java:214)
	at org.springframework.beans.propertyeditors.CustomNumberEditor.setAsText(CustomNumberEditor.java:115)
	at org.springframework.beans.TypeConverterDelegate.doConvertTextValue(TypeConverterDelegate.java:429)
	at org.springframework.beans.TypeConverterDelegate.doConvertValue(TypeConverterDelegate.java:402)
	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:155)
	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73)
	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:53)
	at org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:693)
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:125)
	... 61 common frames omitted

2020-04-08 15:08:56.018  WARN 19084 --- [http-nio-80-exec-10] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: "null"]
2020-04-08 15:10:37.501  INFO 19084 --- [Thread-5] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2020-04-08 15:10:37.504  INFO 19084 --- [Thread-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2020-04-08 15:10:37.523  INFO 19084 --- [Thread-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2020-04-08 15:10:38.630  INFO 19084 --- [restartedMain] com.hjf.blog.BlogApplication             : Starting BlogApplication on DESKTOP-9T76QD7 with PID 19084 (C:\workspace_idea\blog\target\classes started by hsj in C:\workspace_idea\blog)
2020-04-08 15:10:38.632 DEBUG 19084 --- [restartedMain] com.hjf.blog.BlogApplication             : Running with Spring Boot v2.2.5.RELEASE, Spring v5.2.4.RELEASE
2020-04-08 15:10:38.635  INFO 19084 --- [restartedMain] com.hjf.blog.BlogApplication             : The following profiles are active: dev
2020-04-08 15:10:39.419  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration$$EnhancerBySpringCGLIB$$5c92bd7a] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.429  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration$$EnhancerBySpringCGLIB$$5f25fc1f] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.436  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.hjf.blog.config.shiro.ShiroConfig$$EnhancerBySpringCGLIB$$4ff6ab2e] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.449  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.456  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$7c4e30fa] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.462  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.468  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.477  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'dataSource' of type [com.zaxxer.hikari.HikariDataSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.485  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.555  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.557  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.562  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.565  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [com.sun.proxy.$Proxy120] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.567  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userServiceImpl' of type [com.hjf.blog.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.568  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userRealm' of type [com.hjf.blog.config.shiro.UserRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.575  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'defaultWebSecurityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.584  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'authorizationAttributeSourceAdvisor' of type [org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.596  INFO 19084 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'eventBus' of type [org.apache.shiro.event.support.DefaultEventBus] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:10:39.789  INFO 19084 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 80 (http)
2020-04-08 15:10:39.790  INFO 19084 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-04-08 15:10:39.790  INFO 19084 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-08 15:10:39.854  INFO 19084 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-04-08 15:10:39.854  INFO 19084 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1207 ms
2020-04-08 15:10:40.239  INFO 19084 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-04-08 15:10:40.311  INFO 19084 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-04-08 15:10:41.079  INFO 19084 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-04-08 15:10:41.103  INFO 19084 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 80 (http) with context path ''
2020-04-08 15:10:41.104  INFO 19084 --- [restartedMain] com.hjf.blog.BlogApplication             : Started BlogApplication in 2.669 seconds (JVM running for 147.344)
2020-04-08 15:10:41.106  INFO 19084 --- [restartedMain] .ConditionEvaluationDeltaLoggingListener : Condition evaluation unchanged
2020-04-08 15:10:50.334  INFO 19084 --- [http-nio-80-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-08 15:10:50.335  INFO 19084 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-04-08 15:10:50.354  INFO 19084 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 18 ms
2020-04-08 15:10:51.084  INFO 19084 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:10:51.115  INFO 19084 --- [http-nio-80-exec-7] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...
2020-04-08 15:10:51.127  INFO 19084 --- [http-nio-80-exec-7] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.
2020-04-08 15:10:51.131  INFO 19084 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:10:54.458 ERROR 19084 --- [http-nio-80-exec-10] c.h.b.h.ControllerExceptionHandler       : Request URL : http://localhost/admin/tags/delete/null,Exception : {}

org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: "null"
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:133)
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61)
	at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108)
	at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
	at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
	at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
	at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
	at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:387)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:835)
Caused by: java.lang.NumberFormatException: For input string: "null"
	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68)
	at java.base/java.lang.Long.parseLong(Long.java:699)
	at java.base/java.lang.Long.valueOf(Long.java:1151)
	at org.springframework.util.NumberUtils.parseNumber(NumberUtils.java:214)
	at org.springframework.beans.propertyeditors.CustomNumberEditor.setAsText(CustomNumberEditor.java:115)
	at org.springframework.beans.TypeConverterDelegate.doConvertTextValue(TypeConverterDelegate.java:429)
	at org.springframework.beans.TypeConverterDelegate.doConvertValue(TypeConverterDelegate.java:402)
	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:155)
	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73)
	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:53)
	at org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:693)
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:125)
	... 61 common frames omitted

2020-04-08 15:10:54.459  WARN 19084 --- [http-nio-80-exec-10] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: "null"]
2020-04-08 15:11:16.558  INFO 19084 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2020-04-08 15:11:16.559  INFO 19084 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Shutdown initiated...
2020-04-08 15:11:16.567  INFO 19084 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Shutdown completed.
2020-04-08 15:12:06.222  INFO 29064 --- [restartedMain] com.hjf.blog.BlogApplication             : Starting BlogApplication on DESKTOP-9T76QD7 with PID 29064 (C:\workspace_idea\blog\target\classes started by hsj in C:\workspace_idea\blog)
2020-04-08 15:12:06.226 DEBUG 29064 --- [restartedMain] com.hjf.blog.BlogApplication             : Running with Spring Boot v2.2.5.RELEASE, Spring v5.2.4.RELEASE
2020-04-08 15:12:06.226  INFO 29064 --- [restartedMain] com.hjf.blog.BlogApplication             : The following profiles are active: dev
2020-04-08 15:12:06.298  INFO 29064 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-08 15:12:06.298  INFO 29064 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-08 15:12:07.820  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration$$EnhancerBySpringCGLIB$$27d2fe14] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:07.931  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration$$EnhancerBySpringCGLIB$$2a663cb9] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:07.977  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.hjf.blog.config.shiro.ShiroConfig$$EnhancerBySpringCGLIB$$1b36ebc8] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.135  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.147  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$478e7194] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.157  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.168  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.206  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'dataSource' of type [com.zaxxer.hikari.HikariDataSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.233  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.613  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.625  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.632  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.637  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [com.sun.proxy.$Proxy75] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.643  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userServiceImpl' of type [com.hjf.blog.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.645  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userRealm' of type [com.hjf.blog.config.shiro.UserRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.727  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'defaultWebSecurityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.753  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'authorizationAttributeSourceAdvisor' of type [org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:08.810  INFO 29064 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'eventBus' of type [org.apache.shiro.event.support.DefaultEventBus] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:12:09.338  INFO 29064 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 80 (http)
2020-04-08 15:12:09.353  INFO 29064 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-04-08 15:12:09.353  INFO 29064 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-08 15:12:09.536  INFO 29064 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-04-08 15:12:09.536  INFO 29064 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 3238 ms
2020-04-08 15:12:10.369  INFO 29064 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-04-08 15:12:10.736  INFO 29064 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-04-08 15:12:12.168  INFO 29064 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-04-08 15:12:12.281  INFO 29064 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 80 (http) with context path ''
2020-04-08 15:12:12.287  INFO 29064 --- [restartedMain] com.hjf.blog.BlogApplication             : Started BlogApplication in 7.189 seconds (JVM running for 11.22)
2020-04-08 15:12:17.519  INFO 29064 --- [http-nio-80-exec-2] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-08 15:12:17.521  INFO 29064 --- [http-nio-80-exec-2] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-04-08 15:12:17.558  INFO 29064 --- [http-nio-80-exec-2] o.s.web.servlet.DispatcherServlet        : Completed initialization in 37 ms
2020-04-08 15:12:18.682  WARN 29064 --- [http-nio-80-exec-2] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [1,065] milliseconds.
2020-04-08 15:12:24.830  INFO 29064 --- [http-nio-80-exec-10] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-04-08 15:12:25.016  INFO 29064 --- [http-nio-80-exec-10] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-04-08 15:12:25.159  INFO 29064 --- [http-nio-80-exec-10] c.h.b.controller.admin.LoginController   : 登陆成功
2020-04-08 15:12:25.879  INFO 29064 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:12:25.921  INFO 29064 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:12:27.581  INFO 29064 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:12:27.586  INFO 29064 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:13:22.459  WARN 29064 --- [HikariPool-1 housekeeper] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Thread starvation or clock leap detected (housekeeper delta=57s341ms696µs).
2020-04-08 15:13:22.667  INFO 29064 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2020-04-08 15:13:22.677  INFO 29064 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2020-04-08 15:13:22.709  INFO 29064 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2020-04-08 15:14:03.917  INFO 17760 --- [restartedMain] com.hjf.blog.BlogApplication             : Starting BlogApplication on DESKTOP-9T76QD7 with PID 17760 (C:\workspace_idea\blog\target\classes started by hsj in C:\workspace_idea\blog)
2020-04-08 15:14:03.921 DEBUG 17760 --- [restartedMain] com.hjf.blog.BlogApplication             : Running with Spring Boot v2.2.5.RELEASE, Spring v5.2.4.RELEASE
2020-04-08 15:14:03.922  INFO 17760 --- [restartedMain] com.hjf.blog.BlogApplication             : The following profiles are active: dev
2020-04-08 15:14:04.039  INFO 17760 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-08 15:14:04.040  INFO 17760 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-08 15:14:05.648  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration$$EnhancerBySpringCGLIB$$73f78cf4] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:05.760  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration$$EnhancerBySpringCGLIB$$768acb99] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:05.792  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.hjf.blog.config.shiro.ShiroConfig$$EnhancerBySpringCGLIB$$675b7aa8] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:05.964  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:05.984  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$93b30074] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:05.995  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.006  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.053  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'dataSource' of type [com.zaxxer.hikari.HikariDataSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.106  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.690  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.703  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.733  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.740  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [com.sun.proxy.$Proxy75] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.745  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userServiceImpl' of type [com.hjf.blog.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.747  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userRealm' of type [com.hjf.blog.config.shiro.UserRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.902  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'defaultWebSecurityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:06.997  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'authorizationAttributeSourceAdvisor' of type [org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:07.081  INFO 17760 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'eventBus' of type [org.apache.shiro.event.support.DefaultEventBus] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 15:14:08.035  INFO 17760 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 80 (http)
2020-04-08 15:14:08.060  INFO 17760 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-04-08 15:14:08.061  INFO 17760 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-08 15:14:08.315  INFO 17760 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-04-08 15:14:08.317  INFO 17760 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 4276 ms
2020-04-08 15:14:09.488  INFO 17760 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-04-08 15:14:09.805  INFO 17760 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-04-08 15:14:11.164  INFO 17760 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-04-08 15:14:11.277  INFO 17760 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 80 (http) with context path ''
2020-04-08 15:14:11.286  INFO 17760 --- [restartedMain] com.hjf.blog.BlogApplication             : Started BlogApplication in 8.594 seconds (JVM running for 10.887)
2020-04-08 15:14:24.283  INFO 17760 --- [http-nio-80-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-08 15:14:24.285  INFO 17760 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-04-08 15:14:24.320  INFO 17760 --- [http-nio-80-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 35 ms
2020-04-08 15:14:26.005  WARN 17760 --- [http-nio-80-exec-1] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [1,581] milliseconds.
2020-04-08 15:14:33.062  INFO 17760 --- [http-nio-80-exec-4] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-04-08 15:14:33.349  INFO 17760 --- [http-nio-80-exec-4] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-04-08 15:14:33.469  INFO 17760 --- [http-nio-80-exec-4] c.h.b.controller.admin.LoginController   : 登陆成功
2020-04-08 15:14:34.153  INFO 17760 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:14:34.177  INFO 17760 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:14:35.760  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:14:35.766  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:14:38.251 ERROR 17760 --- [http-nio-80-exec-9] c.h.b.h.ControllerExceptionHandler       : Request URL : http://localhost/admin/tags/delete/5,Exception : {}

org.springframework.dao.DataIntegrityViolationException: 
### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`))
### The error may exist in file [C:\workspace_idea\blog\target\classes\mybatis\mapper\TagDao.xml]
### The error may involve defaultParameterMap
### The error occurred while setting parameters
### SQL: delete from t_tag where id = ?
### Cause: java.sql.SQLIntegrityConstraintViolationException: Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`))
; Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`)); nested exception is java.sql.SQLIntegrityConstraintViolationException: Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`))
	at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.doTranslate(SQLErrorCodeSQLExceptionTranslator.java:247)
	at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72)
	at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:88)
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:440)
	at com.sun.proxy.$Proxy74.delete(Unknown Source)
	at org.mybatis.spring.SqlSessionTemplate.delete(SqlSessionTemplate.java:303)
	at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:72)
	at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:144)
	at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:85)
	at com.sun.proxy.$Proxy83.deleteOneTag(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212)
	at com.sun.proxy.$Proxy84.deleteOneTag(Unknown Source)
	at com.hjf.blog.service.impl.TagServiceImpl.deleteTag(TagServiceImpl.java:89)
	at com.hjf.blog.service.impl.TagServiceImpl$$FastClassBySpringCGLIB$$72ecfc7b.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:99)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689)
	at com.hjf.blog.service.impl.TagServiceImpl$$EnhancerBySpringCGLIB$$1d92beda.deleteTag(<generated>)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:99)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212)
	at com.sun.proxy.$Proxy85.deleteTag(Unknown Source)
	at com.hjf.blog.controller.admin.TagController.deleteTag(TagController.java:113)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61)
	at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108)
	at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
	at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
	at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
	at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
	at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:387)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:835)
Caused by: java.sql.SQLIntegrityConstraintViolationException: Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`))
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:117)
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
	at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
	at com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal(ClientPreparedStatement.java:953)
	at com.mysql.cj.jdbc.ClientPreparedStatement.execute(ClientPreparedStatement.java:370)
	at com.zaxxer.hikari.pool.ProxyPreparedStatement.execute(ProxyPreparedStatement.java:44)
	at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.execute(HikariProxyPreparedStatement.java)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.apache.ibatis.logging.jdbc.PreparedStatementLogger.invoke(PreparedStatementLogger.java:59)
	at com.sun.proxy.$Proxy115.execute(Unknown Source)
	at org.apache.ibatis.executor.statement.PreparedStatementHandler.update(PreparedStatementHandler.java:47)
	at org.apache.ibatis.executor.statement.RoutingStatementHandler.update(RoutingStatementHandler.java:74)
	at org.apache.ibatis.executor.SimpleExecutor.doUpdate(SimpleExecutor.java:50)
	at org.apache.ibatis.executor.BaseExecutor.update(BaseExecutor.java:117)
	at org.apache.ibatis.executor.CachingExecutor.update(CachingExecutor.java:76)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:63)
	at com.sun.proxy.$Proxy113.update(Unknown Source)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:197)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.delete(DefaultSqlSession.java:212)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:426)
	... 106 common frames omitted

2020-04-08 15:14:38.253  WARN 17760 --- [http-nio-80-exec-9] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.springframework.dao.DataIntegrityViolationException: 
### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`))
### The error may exist in file [C:\workspace_idea\blog\target\classes\mybatis\mapper\TagDao.xml]
### The error may involve defaultParameterMap
### The error occurred while setting parameters
### SQL: delete from t_tag where id = ?
### Cause: java.sql.SQLIntegrityConstraintViolationException: Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`))
; Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`)); nested exception is java.sql.SQLIntegrityConstraintViolationException: Cannot delete or update a parent row: a foreign key constraint fails (`blog`.`t_tag_blog`, CONSTRAINT `FK_tag_blogTag` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`))]
2020-04-08 15:15:00.200  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:00.206  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:15:03.001  INFO 17760 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:03.010  INFO 17760 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:15:13.211  INFO 17760 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:13.218  INFO 17760 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:15:18.154  INFO 17760 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:18.157  INFO 17760 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:15:22.662  INFO 17760 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:22.665  INFO 17760 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:15:27.575  INFO 17760 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:27.582  INFO 17760 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:15:32.947  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:32.951  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:15:37.116  INFO 17760 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:37.120  INFO 17760 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:15:45.722  INFO 17760 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.index', args=[]}
2020-04-08 15:15:45.723  INFO 17760 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : index
2020-04-08 15:15:47.254  INFO 17760 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 15:15:47.259  INFO 17760 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 15:15:47.304  INFO 17760 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/indexData/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.findIndexData', args=[1]}
2020-04-08 15:15:47.423  INFO 17760 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : {topTags=PageInfo{pageNum=1, pageSize=8, size=6, startRow=1, endRow=6, total=6, pages=1, list=Page{count=true, pageNum=1, pageSize=8, startRow=0, endRow=8, total=6, pages=1, reasonable=true, pageSizeZero=false}[Tag{id=1, tagName='编程', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=3, tagName='音乐', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=4, tagName='吉他', blogs=[Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=5, tagName='旅游', blogs=[Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=7, tagName='动漫', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=6, tagName='篮球', blogs=[Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, topBlogs=PageInfo{pageNum=1, pageSize=5, size=5, startRow=1, endRow=5, total=6, pages=2, list=Page{count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=6, pages=2, reasonable=true, pageSizeZero=false}[Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试测试测试'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=27, title='博客描述测试', content='# 五、SpringBoot与数据访问

## 1、JDBC

```xml
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
```



```yaml
spring:
  datasource:
    username: root
    password: 123456
    # mysql6版本以上要设置时区
    url: jdbc:mysql://192.168.15.22:3306/jdbc?serverTimezone=UTC&characterEncoding=UTF-8
    #springboot推荐用这个mysql驱动 com.mysql.cj.jdbc.Driver
    driver-class-name: com.mysql.jdbc.Driver 
```

效果：

​	默认是用com.zaxxer.hikari.HikariDataSource作为数据源；

​	数据源的相关配置都在DataSourceProperties里面；

自动配置原理：

org.springframework.boot.autoconfigure.jdbc：

1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；

2、SpringBoot默认可以支持；

```
org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、
```

3、自定义数据源类型

```java
/**
 * Generic DataSource configuration.
 */
@ConditionalOnMissingBean(DataSource.class)
@ConditionalOnProperty(name = "spring.datasource.type")
static class Generic {

   @Bean
   public DataSource dataSource(DataSourceProperties properties) {
       //使用DataSourceBuilder创建数据源，利用反射创建相应type的数据源，并且绑定相关属性
      return properties.initializeDataSourceBuilder().build();
   }

}
```

4、**DataSourceInitializer：ApplicationListener**；

​	作用：

​		1）、runSchemaScripts();运行建表语句；

​		2）、runDataScripts();运行插入数据的sql语句；

​		3)   、用SpringBoot初始化DDL和DML 要在配置文件中加这个

​						spring.datasource.initialization-mode:always

​						sql文件里的创建表语句必须在末尾加上';'，例如下面如果最后一个')'后不加';'是可以在Navicat里运行的，但是在Spring Boot的sql文件里必须加上';'，否则会报错

默认只需要将文件命名为：

```properties
schema-*.sql、data-*.sql
默认规则：schema.sql，schema-all.sql；
可以使用   
	schema:
      - classpath:department.sql #这个是建表的sql文件
      指定位置
```

5、操作数据库：**自动配置了JdbcTemplate操作数据库**

## 2、整合Druid数据源

1. 普通的方法换Druid数据池 不推荐使用，了解即可,一般用的多是第二种方法

   - ```xml
     <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
     <dependency>
         <groupId>com.alibaba</groupId>
         <artifactId>druid</artifactId>
         <version>1.1.20</version>
     </dependency>
     ```

  ```yaml
spring:
datasource:
username: root
password: admin
url: jdbc:mysql://localhost:3306/heima?serverTimezone=UTC&characterEncoding=UTF-8
driver-class-name: com.mysql.cj.jdbc.Driver
initialization-mode: always
# 数据源的类型换成Druid
type: com.alibaba.druid.pool.DruidDataSource
  ```

```java
导入druid数据源
@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druid(){
       return  new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
        Map<String,String> initParams = new HashMap<>();

        initParams.put("loginUsername","admin");
        initParams.put("loginPassword","123456");
        initParams.put("allow","");//默认就是允许所有访问
        initParams.put("deny","192.168.15.21");

        bean.setInitParameters(initParams);
        return bean;
    }


    //2、配置一个web监控的filter
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map<String,String> initParams = new HashMap<>();
        initParams.put("exclusions","*.js,*.css,/druid/*");

        bean.setInitParameters(initParams);

        bean.setUrlPatterns(Arrays.asList("/*"));

        return  bean;
    }
}

```

2. 新版SpringBoot以帮我们整合成一个starter:

​        导入的maven依赖

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.21</version>
</dependency>
```

​		 这样会有两个DataSource，我们要把Spring给我们自动配置的类排除掉

```java
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})//排除
public class SpringbootDataJdbcApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootDataJdbcApplication.class, args);
    }

}
```

  	druid的数据池的配置

```yaml
# druid配置
spring:
  datasource:  #数据源配置
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/heima?serverTimezone=UTC&characterEncoding=UTF-8
      username: root
      password: admin
      filters: stat,wall,logback #配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙
      stat-view-servlet: #监控页面配置
        enabled: true   #开启监控页面
        login-username: admin   #监控页面登录名
        login-password: admin   #监控页面密码
        allow:       #监控页面允许谁访问，不写默认所有
        deny:        #监控页面不允许谁访问
        url-pattern: /druid/*
```

3. druid的配置属性详情

```yaml
 # 连接池配置
    druid:
      # 初始化大小，最小，最大
      initial-size: 5
      min-idle: 5
      max-active: 20
      # 配置获取连接等待超时的时间
      max-wait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位毫秒
      time-between-eviction-runs-millis: 60000
      # 配置一个连接在池中最小生存时间
      min-evictable-idle-time-millis: 300000
      validation-query: SELECT 1 FROM sys_user
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      # 打开 PSCache，并且指定每个连接上 PSCache 的大小
      pool-prepared-statements: true
      max-pool-prepared-statement-per-connection-size: 20
      # 配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙
      filters: stat,wall,log4j
      # 通过 connection-properties 属性打开 mergeSql 功能；慢 SQL 记录
      connection-properties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
      # 配置 DruidStatFilter
      web-stat-filter:
        enabled: true
        url-pattern: /*
        exclusions: .js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*
      # 配置 DruidStatViewServlet
      stat-view-servlet:
        url-pattern: /druid/*
        # IP 白名单，没有配置或者为空，则允许所有访问
        allow: 127.0.0.1
        # IP 黑名单，若白名单也存在，则优先使用
        deny: 192.168.31.253
        # 禁用 HTML 中 Reset All 按钮
        reset-enable: false
        # 登录用户名/密码
        login-username: root
        login-password: 123
```

| 配置                          | 缺省值             | 说明                                                         |
| ----------------------------- | ------------------ | ------------------------------------------------------------ |
| name                          |                    | 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是："DataSource-" + System.identityHashCode(this).  另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 [详情-点此处](http://blog.csdn.net/lanmo555/article/details/41248763)。 |
| url                           |                    | 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2  oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto |
| username                      |                    | 连接数据库的用户名                                           |
| password                      |                    | 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter |
| driverClassName               | 根据url自动识别    | 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName |
| initialSize                   | 0                  | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |
| maxActive                     | 8                  | 最大连接池数量                                               |
| maxIdle                       | 8                  | 已经不再使用，配置了也没效果                                 |
| minIdle                       |                    | 最小连接池数量                                               |
| maxWait                       |                    | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |
| poolPreparedStatements        | false              | 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 |
| maxOpenPreparedStatements     | -1                 | 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 |
| validationQuery               |                    | 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 |
| validationQueryTimeout        |                    | 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 |
| testOnBorrow                  | true               | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |
| testOnReturn                  | false              | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |
| testWhileIdle                 | false              | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 |
| timeBetweenEvictionRunsMillis | 1分钟（1.0.14）    | 有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 |
| numTestsPerEvictionRun        |                    | 不再使用，一个DruidDataSource只支持一个EvictionRun           |
| minEvictableIdleTimeMillis    | 30分钟（1.0.14）   | 连接保持空闲而不被驱逐的最长时间                             |
| connectionInitSqls            |                    | 物理连接初始化的时候执行的sql                                |
| exceptionSorter               | 根据dbType自动识别 | 当数据库抛出一些不可恢复的异常时，抛弃连接                   |
| filters                       |                    | 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall |
| proxyFilters                  |                    | 类型是List<com.alibaba.druid.filter.Filter>，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 |

## 3、整合MyBatis


```xml
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.3.1</version>
		</dependency>
```

![](C:/Users/hsj/Desktop/Java/springboot/Spring Boot 笔记+课件/images/搜狗截图20180305194443.png)

步骤：

​	1）、配置数据源相关属性（见上一节Druid）

​	2）、给数据库建表

​	3）、创建JavaBean

### 	1）、注解版

```java
//指定这是一个操作数据库的mapper
@Mapper
public interface DepartmentMapper {

    @Select("select * from department where id=#{id}")
    public Department getDeptById(Integer id);

    @Delete("delete from department where id=#{id}")
    public int deleteDeptById(Integer id);

    //Options注解useGeneratedKeys自动生成key值返回给department对象.KeyProperty注解表示Key值是department对象的哪个属性
    @Options(useGeneratedKeys = true,keyProperty = "id")
    @Insert("insert into department(departmentName) values(#{departmentName})")
    public int insertDept(Department department);

    @Update("update department set departmentName=#{departmentName} where id=#{id}")
    public int updateDept(Department department);
}
```

问题：

自定义MyBatis的配置规则；给容器中添加一个自定义的ConfigurationCustomizer；

```java
@org.springframework.context.annotation.Configuration
public class MyBatisConfig {

    @Bean
    public ConfigurationCustomizer configurationCustomizer(){
        return new ConfigurationCustomizer(){

            @Override
            public void customize(Configuration configuration) {
                //设置驼峰映射开启
                configuration.setMapUnderscoreToCamelCase(true);
            }
        };
    }
}
```



```java
使用MapperScan批量扫描所有的Mapper接口；
@MapperScan(value = "com.atguigu.springboot.mapper")
@SpringBootApplication
public class SpringBoot06DataMybatisApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);
	}
}
```

### 2）、配置文件版

先要给**Mapper类中添加@Mapper接口**或者在**配置类中添加@MapperScan(value = "com.atguigu.springboot.mapper")**扫描，把Mapper对象装入到SpringBoot的容器中

```yaml
mybatis:
  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置
  mapper-locations: classpath:mybatis/mapper/*.xml  指定sql映射文件的位置
#加了这两句就不需要Mapper接口和sql映射文件放到同一个目录了
```

更多使用参照

http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/

### 3) 、MyBatis开启事务

**使用 @Transactional 注解开启事务**

　　@Transactional标记在方法上，捕获异常就rollback，否则就commit。自动提交事务

**@Transactional注解只能在抛出RuntimeException或者Error时才会触发事务的回滚，常见的非RuntimeException是不会触发事务的回滚的。但是我们平时做业务处理时，需要捕获异常，所以可以手动抛出RuntimeException异常或者添加rollbackFor = Exception.class(也可以指定相应异常)**

**主配置类中开启注解事务管理**

```java
@EnableTransactionManagement // 开启注解事务管理
@SpringBootApplication
public class BlogApplication {

    public static void main(String[] args) {
        SpringApplication.run(BlogApplication.class, args);
    }

}
```

```java
/**
     * @Transactional 的参数
     * value                   |String                        | 可选的限定描述符，指定使用的事务管理器
     * propagation             |Enum: Propagation             | 可选的事务传播行为设置
     * isolation               |Enum: Isolation               | 可选的事务隔离级别设置
     * readOnly                |boolean                       | 读写或只读事务，默认读写
     * timeout                 |int (seconds)                 | 事务超时时间设置
     * rollbackFor             |Class<? extends Throwable>[]  | 导致事务回滚的异常类数组
     * rollbackForClassName    |String[]                      | 导致事务回滚的异常类名字数组
     * noRollbackFor           |Class<? extends Throwable>[]  | 不会导致事务回滚的异常类数组
     * noRollbackForClassName  |String[]                      | 不会导致事务回滚的异常类名字数组
     */
    @Transactional(rollbackFor = Exception.class)
    public void testTransactional() {
            // dosomething..
    }
```

**使用Springboot的事务管理**

​		如果想使用手动提交事务，可以使用该方法。需要注入两个Bean，最后记得提交事务

```java
@Autowired
    private DataSourceTransactionManager dataSourceTransactionManager;
    
    @Autowired
    private TransactionDefinition transactionDefinition;

　　public void testHandleCommitTS(boolean exceptionFlag) {
//        DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();
//        transactionDefinition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        // 开启事务
        TransactionStatus transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);
        try {
            // dosomething
            // 提交事务
            dataSourceTransactionManager.commit(transactionStatus);
        } catch (Exception e) {
            e.printStackTrace();
            // 回滚事务
            dataSourceTransactionManager.rollback(transactionStatus);
        }
    }
```

**@Transactional 注解不生效原因**

​	1、检查你的方法是不是public的。@Transactional注解只能应用到public可见度的方法上，如果应用在protected、private或者package可见度的方法上，也不会报错，不过事务设置不会起作用。

2、检查你的异常类型是不是unchecked异常。默认情况下，Spring会对unchecked异常进行事务回滚，如果是checked异常则不回滚。如空指针异常、算术异常等，会被回滚；文件读写、网络出问题，spring就没法回滚了。如果你想check异常也回滚怎么办，注解上面写明异常类型即可：

```java
@Transactional(rollbackFor = Exception.class)
```

类型的还有norollbackFor，自定义不回滚的异常。

3、是否在service中进行了try...catch的操作，由于已经被捕获异常，故事务也不会回滚。如果非要在service中try...catch异常，又想要事务回滚，可在catch块中抛出运行时异常：

```java
try{
    ....  
}catch(Exception e){
    logger.error("",e);
    throw new RuntimeException;
}
```

这种方法有个不足之处，就是不能在catch块中存在return子句，若想捕获异常时回滚事务，同时返回提示信息，可以使用手动回滚：

```java
try{
    ...
}catch(Exception e){
    logger.error("",e);
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    return ERROR_MESSAGE;
}
```

PS:另外说明一下，在controller层捕获了service层的异常，事务还会回滚吗？答案是会的，只要你service层抛出了异常，并且你加的事务可以处理这个异常，也就是rollbackFor = Exception.class这个符合你抛出的异常，不管外面有没有捕获都可以回滚。

**注意**

**注解自动事务和手动事务不能一起用**

### 4) 、分页插件PageHelper

pom.xml:

```xml
<!-- 引入分页插件 -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.2.13</version>
</dependency>
```

application.yml:

```yaml
# 分页配置
pagehelper:
  helper-dialect: mysql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql
```

java:

```java
/**
 * 分页查询Type
 * @param start
 * @param count
 * @return
 */
@Override
public PageInfo<Type> listType(int start, int count) {
    PageHelper.startPage(start, count);
    List<Type> types = typeDao.findAllType();
    PageInfo<Type> pageInfo = new PageInfo<>(types);
    return pageInfo;
}
```

PageInfo返回json的数据解释

```java
当前页 
private int pageNum;
每页的数量  
private int pageSize;  
当前页的数量  
private int size;  
//由于startRow和endRow不常用，这里说个具体的用法  
//可以在页面中"显示startRow到endRow 共size条数据"  

当前页面第一个元素在数据库中的行号  
private int startRow;  
当前页面最后一个元素在数据库中的行号  
private int endRow;  
总记录数  
private long total;  
总页数  
private int pages;  
结果集  
private List<T> list;  

第一页  
private int firstPage;  
前一页  
private int prePage;  

是否为第一页  
private boolean isFirstPage = false;  
是否为最后一页  
private boolean isLastPage = false;  
是否有前一页  
private boolean hasPreviousPage = false;  
是否有下一页  
private boolean hasNextPage = false;  
导航页码数  
private int navigatePages;  
所有导航页号  
private int[] navigatepageNums;  
后台分页
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Mon Apr 02 22:16:00 CST 2018, updateTime=Sun Apr 05 23:17:55 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试测试测试'}], prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=8, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]}, blogs=PageInfo{pageNum=1, pageSize=7, size=6, startRow=1, endRow=6, total=6, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=6, pages=1, reasonable=true, pageSizeZero=false}[Blog{id=20, title='测试1', content='# 一、SpringBoot入门

## 1.回顾Spring

### 1.1、什么是Spring

Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。

**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**



### 1.2、Spring是如何简化Java开发的

为了降低Java开发的复杂性，Spring采用了以下4种关键策略：

1、基于POJO的轻量级和最小侵入性编程；

2、通过IOC，依赖注入（DI）和面向接口实现松耦合；

3、基于切面（AOP）和惯例进行声明式编程；

4、通过切面和模版减少样式代码；



### 1.3、什么是SpringBoot

学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤； 后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；不知道你们有没经历过框架不断的演进，然后自己开发项目所有的技术也再不断的变化、改造，反正我是都经历过了，哈哈。言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can "just run"，能迅速的开发web应用，几行代码开发一个http接口。

所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。

是的这就是Java企业级应用->J2EE->spring->springboot的过程。

随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；

Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，

简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。

Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。

**Spring Boot的主要优点：**

- 为所有Spring开发者更快的入门
- **开箱即用**，提供各种默认配置来简化项目配置
- 内嵌式容器简化Web项目
- 没有冗余代码生成和XML配置的要求', firstPicture='/images/avatar.jpg', flag='原创', views=58, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Sat Apr 01 21:30:43 CST 2017, updateTime=Sun Apr 02 22:13:27 CST 2017, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试1的说明'}, Blog{id=27, title='博客描述测试', content='# 五、SpringBoot与数据访问

## 1、JDBC

```xml
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
```



```yaml
spring:
  datasource:
    username: root
    password: 123456
    # mysql6版本以上要设置时区
    url: jdbc:mysql://192.168.15.22:3306/jdbc?serverTimezone=UTC&characterEncoding=UTF-8
    #springboot推荐用这个mysql驱动 com.mysql.cj.jdbc.Driver
    driver-class-name: com.mysql.jdbc.Driver 
```

效果：

​	默认是用com.zaxxer.hikari.HikariDataSource作为数据源；

​	数据源的相关配置都在DataSourceProperties里面；

自动配置原理：

org.springframework.boot.autoconfigure.jdbc：

1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；

2、SpringBoot默认可以支持；

```
org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、
```

3、自定义数据源类型

```java
/**
 * Generic DataSource configuration.
 */
@ConditionalOnMissingBean(DataSource.class)
@ConditionalOnProperty(name = "spring.datasource.type")
static class Generic {

   @Bean
   public DataSource dataSource(DataSourceProperties properties) {
       //使用DataSourceBuilder创建数据源，利用反射创建相应type的数据源，并且绑定相关属性
      return properties.initializeDataSourceBuilder().build();
   }

}
```

4、**DataSourceInitializer：ApplicationListener**；

​	作用：

​		1）、runSchemaScripts();运行建表语句；

​		2）、runDataScripts();运行插入数据的sql语句；

​		3)   、用SpringBoot初始化DDL和DML 要在配置文件中加这个

​						spring.datasource.initialization-mode:always

​						sql文件里的创建表语句必须在末尾加上';'，例如下面如果最后一个')'后不加';'是可以在Navicat里运行的，但是在Spring Boot的sql文件里必须加上';'，否则会报错

默认只需要将文件命名为：

```properties
schema-*.sql、data-*.sql
默认规则：schema.sql，schema-all.sql；
可以使用   
	schema:
      - classpath:department.sql #这个是建表的sql文件
      指定位置
```

5、操作数据库：**自动配置了JdbcTemplate操作数据库**

## 2、整合Druid数据源

1. 普通的方法换Druid数据池 不推荐使用，了解即可,一般用的多是第二种方法

   - ```xml
     <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
     <dependency>
         <groupId>com.alibaba</groupId>
         <artifactId>druid</artifactId>
         <version>1.1.20</version>
     </dependency>
     ```

  ```yaml
spring:
datasource:
username: root
password: admin
url: jdbc:mysql://localhost:3306/heima?serverTimezone=UTC&characterEncoding=UTF-8
driver-class-name: com.mysql.cj.jdbc.Driver
initialization-mode: always
# 数据源的类型换成Druid
type: com.alibaba.druid.pool.DruidDataSource
  ```

```java
导入druid数据源
@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druid(){
       return  new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
        Map<String,String> initParams = new HashMap<>();

        initParams.put("loginUsername","admin");
        initParams.put("loginPassword","123456");
        initParams.put("allow","");//默认就是允许所有访问
        initParams.put("deny","192.168.15.21");

        bean.setInitParameters(initParams);
        return bean;
    }


    //2、配置一个web监控的filter
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map<String,String> initParams = new HashMap<>();
        initParams.put("exclusions","*.js,*.css,/druid/*");

        bean.setInitParameters(initParams);

        bean.setUrlPatterns(Arrays.asList("/*"));

        return  bean;
    }
}

```

2. 新版SpringBoot以帮我们整合成一个starter:

​        导入的maven依赖

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.21</version>
</dependency>
```

​		 这样会有两个DataSource，我们要把Spring给我们自动配置的类排除掉

```java
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})//排除
public class SpringbootDataJdbcApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootDataJdbcApplication.class, args);
    }

}
```

  	druid的数据池的配置

```yaml
# druid配置
spring:
  datasource:  #数据源配置
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/heima?serverTimezone=UTC&characterEncoding=UTF-8
      username: root
      password: admin
      filters: stat,wall,logback #配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙
      stat-view-servlet: #监控页面配置
        enabled: true   #开启监控页面
        login-username: admin   #监控页面登录名
        login-password: admin   #监控页面密码
        allow:       #监控页面允许谁访问，不写默认所有
        deny:        #监控页面不允许谁访问
        url-pattern: /druid/*
```

3. druid的配置属性详情

```yaml
 # 连接池配置
    druid:
      # 初始化大小，最小，最大
      initial-size: 5
      min-idle: 5
      max-active: 20
      # 配置获取连接等待超时的时间
      max-wait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位毫秒
      time-between-eviction-runs-millis: 60000
      # 配置一个连接在池中最小生存时间
      min-evictable-idle-time-millis: 300000
      validation-query: SELECT 1 FROM sys_user
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      # 打开 PSCache，并且指定每个连接上 PSCache 的大小
      pool-prepared-statements: true
      max-pool-prepared-statement-per-connection-size: 20
      # 配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙
      filters: stat,wall,log4j
      # 通过 connection-properties 属性打开 mergeSql 功能；慢 SQL 记录
      connection-properties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000
      # 配置 DruidStatFilter
      web-stat-filter:
        enabled: true
        url-pattern: /*
        exclusions: .js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*
      # 配置 DruidStatViewServlet
      stat-view-servlet:
        url-pattern: /druid/*
        # IP 白名单，没有配置或者为空，则允许所有访问
        allow: 127.0.0.1
        # IP 黑名单，若白名单也存在，则优先使用
        deny: 192.168.31.253
        # 禁用 HTML 中 Reset All 按钮
        reset-enable: false
        # 登录用户名/密码
        login-username: root
        login-password: 123
```

| 配置                          | 缺省值             | 说明                                                         |
| ----------------------------- | ------------------ | ------------------------------------------------------------ |
| name                          |                    | 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是："DataSource-" + System.identityHashCode(this).  另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 [详情-点此处](http://blog.csdn.net/lanmo555/article/details/41248763)。 |
| url                           |                    | 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2  oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto |
| username                      |                    | 连接数据库的用户名                                           |
| password                      |                    | 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter |
| driverClassName               | 根据url自动识别    | 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName |
| initialSize                   | 0                  | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |
| maxActive                     | 8                  | 最大连接池数量                                               |
| maxIdle                       | 8                  | 已经不再使用，配置了也没效果                                 |
| minIdle                       |                    | 最小连接池数量                                               |
| maxWait                       |                    | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |
| poolPreparedStatements        | false              | 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 |
| maxOpenPreparedStatements     | -1                 | 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 |
| validationQuery               |                    | 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 |
| validationQueryTimeout        |                    | 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 |
| testOnBorrow                  | true               | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |
| testOnReturn                  | false              | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |
| testWhileIdle                 | false              | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 |
| timeBetweenEvictionRunsMillis | 1分钟（1.0.14）    | 有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 |
| numTestsPerEvictionRun        |                    | 不再使用，一个DruidDataSource只支持一个EvictionRun           |
| minEvictableIdleTimeMillis    | 30分钟（1.0.14）   | 连接保持空闲而不被驱逐的最长时间                             |
| connectionInitSqls            |                    | 物理连接初始化的时候执行的sql                                |
| exceptionSorter               | 根据dbType自动识别 | 当数据库抛出一些不可恢复的异常时，抛弃连接                   |
| filters                       |                    | 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall |
| proxyFilters                  |                    | 类型是List<com.alibaba.druid.filter.Filter>，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 |

## 3、整合MyBatis


```xml
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.3.1</version>
		</dependency>
```

![](C:/Users/hsj/Desktop/Java/springboot/Spring Boot 笔记+课件/images/搜狗截图20180305194443.png)

步骤：

​	1）、配置数据源相关属性（见上一节Druid）

​	2）、给数据库建表

​	3）、创建JavaBean

### 	1）、注解版

```java
//指定这是一个操作数据库的mapper
@Mapper
public interface DepartmentMapper {

    @Select("select * from department where id=#{id}")
    public Department getDeptById(Integer id);

    @Delete("delete from department where id=#{id}")
    public int deleteDeptById(Integer id);

    //Options注解useGeneratedKeys自动生成key值返回给department对象.KeyProperty注解表示Key值是department对象的哪个属性
    @Options(useGeneratedKeys = true,keyProperty = "id")
    @Insert("insert into department(departmentName) values(#{departmentName})")
    public int insertDept(Department department);

    @Update("update department set departmentName=#{departmentName} where id=#{id}")
    public int updateDept(Department department);
}
```

问题：

自定义MyBatis的配置规则；给容器中添加一个自定义的ConfigurationCustomizer；

```java
@org.springframework.context.annotation.Configuration
public class MyBatisConfig {

    @Bean
    public ConfigurationCustomizer configurationCustomizer(){
        return new ConfigurationCustomizer(){

            @Override
            public void customize(Configuration configuration) {
                //设置驼峰映射开启
                configuration.setMapUnderscoreToCamelCase(true);
            }
        };
    }
}
```



```java
使用MapperScan批量扫描所有的Mapper接口；
@MapperScan(value = "com.atguigu.springboot.mapper")
@SpringBootApplication
public class SpringBoot06DataMybatisApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);
	}
}
```

### 2）、配置文件版

先要给**Mapper类中添加@Mapper接口**或者在**配置类中添加@MapperScan(value = "com.atguigu.springboot.mapper")**扫描，把Mapper对象装入到SpringBoot的容器中

```yaml
mybatis:
  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置
  mapper-locations: classpath:mybatis/mapper/*.xml  指定sql映射文件的位置
#加了这两句就不需要Mapper接口和sql映射文件放到同一个目录了
```

更多使用参照

http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/

### 3) 、MyBatis开启事务

**使用 @Transactional 注解开启事务**

　　@Transactional标记在方法上，捕获异常就rollback，否则就commit。自动提交事务

**@Transactional注解只能在抛出RuntimeException或者Error时才会触发事务的回滚，常见的非RuntimeException是不会触发事务的回滚的。但是我们平时做业务处理时，需要捕获异常，所以可以手动抛出RuntimeException异常或者添加rollbackFor = Exception.class(也可以指定相应异常)**

**主配置类中开启注解事务管理**

```java
@EnableTransactionManagement // 开启注解事务管理
@SpringBootApplication
public class BlogApplication {

    public static void main(String[] args) {
        SpringApplication.run(BlogApplication.class, args);
    }

}
```

```java
/**
     * @Transactional 的参数
     * value                   |String                        | 可选的限定描述符，指定使用的事务管理器
     * propagation             |Enum: Propagation             | 可选的事务传播行为设置
     * isolation               |Enum: Isolation               | 可选的事务隔离级别设置
     * readOnly                |boolean                       | 读写或只读事务，默认读写
     * timeout                 |int (seconds)                 | 事务超时时间设置
     * rollbackFor             |Class<? extends Throwable>[]  | 导致事务回滚的异常类数组
     * rollbackForClassName    |String[]                      | 导致事务回滚的异常类名字数组
     * noRollbackFor           |Class<? extends Throwable>[]  | 不会导致事务回滚的异常类数组
     * noRollbackForClassName  |String[]                      | 不会导致事务回滚的异常类名字数组
     */
    @Transactional(rollbackFor = Exception.class)
    public void testTransactional() {
            // dosomething..
    }
```

**使用Springboot的事务管理**

​		如果想使用手动提交事务，可以使用该方法。需要注入两个Bean，最后记得提交事务

```java
@Autowired
    private DataSourceTransactionManager dataSourceTransactionManager;
    
    @Autowired
    private TransactionDefinition transactionDefinition;

　　public void testHandleCommitTS(boolean exceptionFlag) {
//        DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();
//        transactionDefinition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        // 开启事务
        TransactionStatus transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);
        try {
            // dosomething
            // 提交事务
            dataSourceTransactionManager.commit(transactionStatus);
        } catch (Exception e) {
            e.printStackTrace();
            // 回滚事务
            dataSourceTransactionManager.rollback(transactionStatus);
        }
    }
```

**@Transactional 注解不生效原因**

​	1、检查你的方法是不是public的。@Transactional注解只能应用到public可见度的方法上，如果应用在protected、private或者package可见度的方法上，也不会报错，不过事务设置不会起作用。

2、检查你的异常类型是不是unchecked异常。默认情况下，Spring会对unchecked异常进行事务回滚，如果是checked异常则不回滚。如空指针异常、算术异常等，会被回滚；文件读写、网络出问题，spring就没法回滚了。如果你想check异常也回滚怎么办，注解上面写明异常类型即可：

```java
@Transactional(rollbackFor = Exception.class)
```

类型的还有norollbackFor，自定义不回滚的异常。

3、是否在service中进行了try...catch的操作，由于已经被捕获异常，故事务也不会回滚。如果非要在service中try...catch异常，又想要事务回滚，可在catch块中抛出运行时异常：

```java
try{
    ....  
}catch(Exception e){
    logger.error("",e);
    throw new RuntimeException;
}
```

这种方法有个不足之处，就是不能在catch块中存在return子句，若想捕获异常时回滚事务，同时返回提示信息，可以使用手动回滚：

```java
try{
    ...
}catch(Exception e){
    logger.error("",e);
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    return ERROR_MESSAGE;
}
```

PS:另外说明一下，在controller层捕获了service层的异常，事务还会回滚吗？答案是会的，只要你service层抛出了异常，并且你加的事务可以处理这个异常，也就是rollbackFor = Exception.class这个符合你抛出的异常，不管外面有没有捕获都可以回滚。

**注意**

**注解自动事务和手动事务不能一起用**

### 4) 、分页插件PageHelper

pom.xml:

```xml
<!-- 引入分页插件 -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.2.13</version>
</dependency>
```

application.yml:

```yaml
# 分页配置
pagehelper:
  helper-dialect: mysql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql
```

java:

```java
/**
 * 分页查询Type
 * @param start
 * @param count
 * @return
 */
@Override
public PageInfo<Type> listType(int start, int count) {
    PageHelper.startPage(start, count);
    List<Type> types = typeDao.findAllType();
    PageInfo<Type> pageInfo = new PageInfo<>(types);
    return pageInfo;
}
```

PageInfo返回json的数据解释

```java
当前页 
private int pageNum;
每页的数量  
private int pageSize;  
当前页的数量  
private int size;  
//由于startRow和endRow不常用，这里说个具体的用法  
//可以在页面中"显示startRow到endRow 共size条数据"  

当前页面第一个元素在数据库中的行号  
private int startRow;  
当前页面最后一个元素在数据库中的行号  
private int endRow;  
总记录数  
private long total;  
总页数  
private int pages;  
结果集  
private List<T> list;  

第一页  
private int firstPage;  
前一页  
private int prePage;  

是否为第一页  
private boolean isFirstPage = false;  
是否为最后一页  
private boolean isLastPage = false;  
是否有前一页  
private boolean hasPreviousPage = false;  
是否有下一页  
private boolean hasNextPage = false;  
导航页码数  
private int navigatePages;  
所有导航页号  
private int[] navigatepageNums;  
后台分页
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Mon Apr 02 22:16:00 CST 2018, updateTime=Sun Apr 05 23:17:55 CST 2020, type=Type{id=1, typeName='Java', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试测试测试'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=Type{id=1, typeName='Java', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试测试测试'}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, totalBlogsCount=6, topTypes=PageInfo{pageNum=1, pageSize=7, size=3, startRow=1, endRow=3, total=6, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=6, pages=1, reasonable=true, pageSizeZero=false}[Type{id=1, typeName='Java', blogs=[Blog{id=27, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=38, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=6, typeName='SpringBoot', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=7, typeName='Mybatis', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}}
2020-04-08 15:15:49.893  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/tags/-1/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.TagShowController.tags', args=[-1, 1, {}]}
2020-04-08 15:15:49.959  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : tags
2020-04-08 15:15:50.686  INFO 17760 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 15:15:50.689  INFO 17760 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 15:15:52.676  INFO 17760 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/tags/6/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.TagShowController.tags', args=[6, 1, {}]}
2020-04-08 15:15:52.723  INFO 17760 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : tags
2020-04-08 15:15:53.500  INFO 17760 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 15:15:53.510  INFO 17760 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 15:15:59.039  INFO 17760 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:15:59.042  INFO 17760 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:16:16.238  INFO 17760 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:16:16.240  INFO 17760 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:16:21.250  INFO 17760 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/tags/6/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.TagShowController.tags', args=[6, 1, {}]}
2020-04-08 15:16:21.291  INFO 17760 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : tags
2020-04-08 15:16:22.118  INFO 17760 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 15:16:22.121  INFO 17760 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 15:16:24.866  INFO 17760 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/tags/4/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.TagShowController.tags', args=[4, 1, {}]}
2020-04-08 15:16:24.913  INFO 17760 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : tags
2020-04-08 15:16:25.521  INFO 17760 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 15:16:25.523  INFO 17760 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 15:16:28.973  INFO 17760 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:16:28.976  INFO 17760 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:16:32.183  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/admin/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.adminBlogs', args=[{}]}
2020-04-08 15:16:32.185  INFO 17760 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : admin/_fragments :: newAdminBlogList
2020-04-08 15:16:46.485  INFO 17760 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2020-04-08 15:16:46.488  INFO 17760 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2020-04-08 15:16:46.498  INFO 17760 --- [SpringContextShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2020-04-08 19:07:57.242  INFO 13224 --- [restartedMain] com.hjf.blog.BlogApplication             : Starting BlogApplication on DESKTOP-9T76QD7 with PID 13224 (C:\workspace_idea\blog\target\classes started by hsj in C:\workspace_idea\blog)
2020-04-08 19:07:57.248 DEBUG 13224 --- [restartedMain] com.hjf.blog.BlogApplication             : Running with Spring Boot v2.2.5.RELEASE, Spring v5.2.4.RELEASE
2020-04-08 19:07:57.249  INFO 13224 --- [restartedMain] com.hjf.blog.BlogApplication             : The following profiles are active: dev
2020-04-08 19:07:57.446  INFO 13224 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-08 19:07:57.448  INFO 13224 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-08 19:07:59.488  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration$$EnhancerBySpringCGLIB$$e69869ca] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:07:59.738  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration' of type [org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration$$EnhancerBySpringCGLIB$$e92ba86f] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:07:59.810  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.hjf.blog.config.shiro.ShiroConfig$$EnhancerBySpringCGLIB$$d9fc577e] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.131  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.144  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$653dd4a] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.164  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.181  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.253  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'dataSource' of type [com.zaxxer.hikari.HikariDataSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.285  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.565  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.575  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.584  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.591  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userDao' of type [com.sun.proxy.$Proxy75] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.594  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userServiceImpl' of type [com.hjf.blog.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.595  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'userRealm' of type [com.hjf.blog.config.shiro.UserRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.660  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'defaultWebSecurityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.682  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'authorizationAttributeSourceAdvisor' of type [org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:00.719  INFO 13224 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'eventBus' of type [org.apache.shiro.event.support.DefaultEventBus] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-08 19:08:01.181  INFO 13224 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 80 (http)
2020-04-08 19:08:01.193  INFO 13224 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-04-08 19:08:01.193  INFO 13224 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-08 19:08:01.322  INFO 13224 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-04-08 19:08:01.323  INFO 13224 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 3872 ms
2020-04-08 19:08:01.988  INFO 13224 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-04-08 19:08:02.121  INFO 13224 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-04-08 19:08:03.080  INFO 13224 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-04-08 19:08:03.322  INFO 13224 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 80 (http) with context path ''
2020-04-08 19:08:03.330  INFO 13224 --- [restartedMain] com.hjf.blog.BlogApplication             : Started BlogApplication in 7.085 seconds (JVM running for 9.501)
2020-04-08 19:08:32.063  INFO 13224 --- [http-nio-80-exec-10] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-08 19:08:32.064  INFO 13224 --- [http-nio-80-exec-10] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-04-08 19:08:32.099  INFO 13224 --- [http-nio-80-exec-10] o.s.web.servlet.DispatcherServlet        : Completed initialization in 35 ms
2020-04-08 19:08:32.803  WARN 13224 --- [http-nio-80-exec-10] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [639] milliseconds.
2020-04-08 19:08:34.858  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.index', args=[]}
2020-04-08 19:08:34.867  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : index
2020-04-08 19:08:35.865  INFO 13224 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:08:35.917  INFO 13224 --- [http-nio-80-exec-10] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-04-08 19:08:35.919  INFO 13224 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/indexData/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.findIndexData', args=[1]}
2020-04-08 19:08:36.234  INFO 13224 --- [http-nio-80-exec-10] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-04-08 19:08:36.453  INFO 13224 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:08:36.614  INFO 13224 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Result : {topTags=PageInfo{pageNum=1, pageSize=8, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=8, startRow=0, endRow=8, total=5, pages=1, reasonable=true, pageSizeZero=false}[Tag{id=1, tagName='编程', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=7, tagName='动漫', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=3, tagName='音乐', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=4, tagName='吉他', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=5, tagName='旅游', blogs=[Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, topBlogs=PageInfo{pageNum=1, pageSize=5, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=5, pages=1, reasonable=true, pageSizeZero=false}[Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试测试测试'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=20, title='测试1', content='# 一、SpringBoot入门

## 1.回顾Spring

### 1.1、什么是Spring

Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。

**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**



### 1.2、Spring是如何简化Java开发的

为了降低Java开发的复杂性，Spring采用了以下4种关键策略：

1、基于POJO的轻量级和最小侵入性编程；

2、通过IOC，依赖注入（DI）和面向接口实现松耦合；

3、基于切面（AOP）和惯例进行声明式编程；

4、通过切面和模版减少样式代码；



### 1.3、什么是SpringBoot

学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤； 后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；不知道你们有没经历过框架不断的演进，然后自己开发项目所有的技术也再不断的变化、改造，反正我是都经历过了，哈哈。言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can "just run"，能迅速的开发web应用，几行代码开发一个http接口。

所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。

是的这就是Java企业级应用->J2EE->spring->springboot的过程。

随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；

Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，

简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。

Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。

**Spring Boot的主要优点：**

- 为所有Spring开发者更快的入门
- **开箱即用**，提供各种默认配置来简化项目配置
- 内嵌式容器简化Web项目
- 没有冗余代码生成和XML配置的要求', firstPicture='/images/avatar.jpg', flag='原创', views=58, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Sat Apr 01 21:30:43 CST 2017, updateTime=Sun Apr 02 22:13:27 CST 2017, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试1的说明'}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, blogs=PageInfo{pageNum=1, pageSize=7, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=5, pages=1, reasonable=true, pageSizeZero=false}[Blog{id=20, title='测试1', content='# 一、SpringBoot入门

## 1.回顾Spring

### 1.1、什么是Spring

Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。

**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**



### 1.2、Spring是如何简化Java开发的

为了降低Java开发的复杂性，Spring采用了以下4种关键策略：

1、基于POJO的轻量级和最小侵入性编程；

2、通过IOC，依赖注入（DI）和面向接口实现松耦合；

3、基于切面（AOP）和惯例进行声明式编程；

4、通过切面和模版减少样式代码；



### 1.3、什么是SpringBoot

学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤； 后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；不知道你们有没经历过框架不断的演进，然后自己开发项目所有的技术也再不断的变化、改造，反正我是都经历过了，哈哈。言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can "just run"，能迅速的开发web应用，几行代码开发一个http接口。

所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。

是的这就是Java企业级应用->J2EE->spring->springboot的过程。

随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；

Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，

简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。

Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。

**Spring Boot的主要优点：**

- 为所有Spring开发者更快的入门
- **开箱即用**，提供各种默认配置来简化项目配置
- 内嵌式容器简化Web项目
- 没有冗余代码生成和XML配置的要求', firstPicture='/images/avatar.jpg', flag='原创', views=58, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Sat Apr 01 21:30:43 CST 2017, updateTime=Sun Apr 02 22:13:27 CST 2017, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试1的说明'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=Type{id=1, typeName='Java', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试测试测试'}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, totalBlogsCount=5, topTypes=PageInfo{pageNum=1, pageSize=7, size=3, startRow=1, endRow=3, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=5, pages=1, reasonable=true, pageSizeZero=false}[Type{id=6, typeName='SpringBoot', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=7, typeName='Mybatis', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=1, typeName='Java', blogs=[Blog{id=38, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}}
2020-04-08 19:08:38.988  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@3cc6720a]}
2020-04-08 19:08:39.120  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:08:40.452  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:08:40.460  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:09:04.032  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@3550ef42]}
2020-04-08 19:09:04.068  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:09:05.426  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:09:05.486  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:09:38.814  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@77d6ee]}
2020-04-08 19:09:38.845  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:09:39.925  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:09:39.929  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:13:05.892  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@55277c08]}
2020-04-08 19:13:05.919  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:13:06.880  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:13:06.883  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:14:35.880  INFO 13224 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@3ec2aade]}
2020-04-08 19:14:35.913  INFO 13224 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:14:36.862  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:14:36.866  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:15:18.359  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@60641dd9]}
2020-04-08 19:15:18.392  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:15:19.251  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:15:19.255  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:45:14.676  INFO 13224 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.index', args=[]}
2020-04-08 19:45:14.677  INFO 13224 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : index
2020-04-08 19:45:15.896  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:45:15.901  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:45:15.936  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/indexData/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.findIndexData', args=[1]}
2020-04-08 19:45:16.030  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : {topTags=PageInfo{pageNum=1, pageSize=8, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=8, startRow=0, endRow=8, total=5, pages=1, reasonable=true, pageSizeZero=false}[Tag{id=1, tagName='编程', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=7, tagName='动漫', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=3, tagName='音乐', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=4, tagName='吉他', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=5, tagName='旅游', blogs=[Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, topBlogs=PageInfo{pageNum=1, pageSize=5, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=5, pages=1, reasonable=true, pageSizeZero=false}[Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试测试测试'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=20, title='测试1', content='# 一、SpringBoot入门

## 1.回顾Spring

### 1.1、什么是Spring

Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。

**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**



### 1.2、Spring是如何简化Java开发的

为了降低Java开发的复杂性，Spring采用了以下4种关键策略：

1、基于POJO的轻量级和最小侵入性编程；

2、通过IOC，依赖注入（DI）和面向接口实现松耦合；

3、基于切面（AOP）和惯例进行声明式编程；

4、通过切面和模版减少样式代码；



### 1.3、什么是SpringBoot

学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤； 后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；不知道你们有没经历过框架不断的演进，然后自己开发项目所有的技术也再不断的变化、改造，反正我是都经历过了，哈哈。言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can "just run"，能迅速的开发web应用，几行代码开发一个http接口。

所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。

是的这就是Java企业级应用->J2EE->spring->springboot的过程。

随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；

Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，

简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。

Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。

**Spring Boot的主要优点：**

- 为所有Spring开发者更快的入门
- **开箱即用**，提供各种默认配置来简化项目配置
- 内嵌式容器简化Web项目
- 没有冗余代码生成和XML配置的要求', firstPicture='/images/avatar.jpg', flag='原创', views=64, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Sat Apr 01 21:30:43 CST 2017, updateTime=Sun Apr 02 22:13:27 CST 2017, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试1的说明'}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, blogs=PageInfo{pageNum=1, pageSize=7, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=5, pages=1, reasonable=true, pageSizeZero=false}[Blog{id=20, title='测试1', content='# 一、SpringBoot入门

## 1.回顾Spring

### 1.1、什么是Spring

Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。

**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**



### 1.2、Spring是如何简化Java开发的

为了降低Java开发的复杂性，Spring采用了以下4种关键策略：

1、基于POJO的轻量级和最小侵入性编程；

2、通过IOC，依赖注入（DI）和面向接口实现松耦合；

3、基于切面（AOP）和惯例进行声明式编程；

4、通过切面和模版减少样式代码；



### 1.3、什么是SpringBoot

学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤； 后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；不知道你们有没经历过框架不断的演进，然后自己开发项目所有的技术也再不断的变化、改造，反正我是都经历过了，哈哈。言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can "just run"，能迅速的开发web应用，几行代码开发一个http接口。

所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。

是的这就是Java企业级应用->J2EE->spring->springboot的过程。

随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；

Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，

简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。

Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。

**Spring Boot的主要优点：**

- 为所有Spring开发者更快的入门
- **开箱即用**，提供各种默认配置来简化项目配置
- 内嵌式容器简化Web项目
- 没有冗余代码生成和XML配置的要求', firstPicture='/images/avatar.jpg', flag='原创', views=64, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Sat Apr 01 21:30:43 CST 2017, updateTime=Sun Apr 02 22:13:27 CST 2017, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试1的说明'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=Type{id=1, typeName='Java', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试测试测试'}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, totalBlogsCount=5, topTypes=PageInfo{pageNum=1, pageSize=7, size=3, startRow=1, endRow=3, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=5, pages=1, reasonable=true, pageSizeZero=false}[Type{id=6, typeName='SpringBoot', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=7, typeName='Mybatis', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=1, typeName='Java', blogs=[Blog{id=38, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}}
2020-04-08 19:45:17.763  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@3e4a1a0b]}
2020-04-08 19:45:17.782  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:45:18.805  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:45:18.808  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:45:32.275  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@12f4f8bb]}
2020-04-08 19:45:32.300  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:45:33.359  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:45:33.363  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:45:58.666  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@16fa6a88]}
2020-04-08 19:45:58.697  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:45:59.665  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:45:59.670  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:46:15.918  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@69fc308]}
2020-04-08 19:46:15.948  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:46:17.645  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:46:17.648  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:47:09.369  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@72b4fbdd]}
2020-04-08 19:47:09.392  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:47:10.434  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:47:10.438  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:48:12.418  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@1ceb7136]}
2020-04-08 19:48:12.439  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:48:13.438  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:48:13.441  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:51:52.135  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@3432187]}
2020-04-08 19:51:52.162  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:51:53.340  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:51:53.343  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:54:08.434  INFO 13224 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@52ef7462]}
2020-04-08 19:54:08.455  INFO 13224 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:54:10.176  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:54:10.180  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:55:15.636  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@ebb9823]}
2020-04-08 19:55:15.660  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:55:16.799  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:55:16.802  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:55:53.007  INFO 13224 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@193a57f5]}
2020-04-08 19:55:53.040  INFO 13224 --- [http-nio-80-exec-2] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:55:54.267  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:55:54.271  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:57:02.807  INFO 13224 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@5c5081c7]}
2020-04-08 19:57:02.836  INFO 13224 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:57:04.019  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:57:04.022  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 19:58:18.455  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/20', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[20, org.apache.shiro.web.servlet.ShiroHttpServletRequest@6e68383c]}
2020-04-08 19:58:18.484  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 19:58:19.234  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 19:58:19.237  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 20:25:47.865  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.index', args=[]}
2020-04-08 20:25:47.866  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : index
2020-04-08 20:25:54.460  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.index', args=[]}
2020-04-08 20:25:54.460  INFO 13224 --- [http-nio-80-exec-1] com.hjf.blog.aspect.LogAspect            : Result : index
2020-04-08 20:26:02.598  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.index', args=[]}
2020-04-08 20:26:02.599  INFO 13224 --- [http-nio-80-exec-5] com.hjf.blog.aspect.LogAspect            : Result : index
2020-04-08 20:26:13.453  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.index', args=[]}
2020-04-08 20:26:13.454  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : index
2020-04-08 20:26:14.999  INFO 13224 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 20:26:15.005  INFO 13224 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 20:26:15.039  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/indexData/1', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.findIndexData', args=[1]}
2020-04-08 20:26:15.100  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : {topTags=PageInfo{pageNum=1, pageSize=8, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=8, startRow=0, endRow=8, total=5, pages=1, reasonable=true, pageSizeZero=false}[Tag{id=1, tagName='编程', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=7, tagName='动漫', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=3, tagName='音乐', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=4, tagName='吉他', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Tag{id=5, tagName='旅游', blogs=[Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, topBlogs=PageInfo{pageNum=1, pageSize=5, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=5, pages=1, reasonable=true, pageSizeZero=false}[Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试测试测试'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=null, user=null, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=20, title='测试1', content='# 一、SpringBoot入门

## 1.回顾Spring

### 1.1、什么是Spring

Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。

**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**



### 1.2、Spring是如何简化Java开发的

为了降低Java开发的复杂性，Spring采用了以下4种关键策略：

1、基于POJO的轻量级和最小侵入性编程；

2、通过IOC，依赖注入（DI）和面向接口实现松耦合；

3、基于切面（AOP）和惯例进行声明式编程；

4、通过切面和模版减少样式代码；



### 1.3、什么是SpringBoot

学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤； 后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；不知道你们有没经历过框架不断的演进，然后自己开发项目所有的技术也再不断的变化、改造，反正我是都经历过了，哈哈。言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can "just run"，能迅速的开发web应用，几行代码开发一个http接口。

所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。

是的这就是Java企业级应用->J2EE->spring->springboot的过程。

随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；

Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，

简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。

Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。

**Spring Boot的主要优点：**

- 为所有Spring开发者更快的入门
- **开箱即用**，提供各种默认配置来简化项目配置
- 内嵌式容器简化Web项目
- 没有冗余代码生成和XML配置的要求', firstPicture='/images/avatar.jpg', flag='原创', views=76, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Sat Apr 01 21:30:43 CST 2017, updateTime=Sun Apr 02 22:13:27 CST 2017, type=null, user=null, tags=[], comments=[], tagIds='null', description='测试1的说明'}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, blogs=PageInfo{pageNum=1, pageSize=7, size=5, startRow=1, endRow=5, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=5, pages=1, reasonable=true, pageSizeZero=false}[Blog{id=20, title='测试1', content='# 一、SpringBoot入门

## 1.回顾Spring

### 1.1、什么是Spring

Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。

**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**



### 1.2、Spring是如何简化Java开发的

为了降低Java开发的复杂性，Spring采用了以下4种关键策略：

1、基于POJO的轻量级和最小侵入性编程；

2、通过IOC，依赖注入（DI）和面向接口实现松耦合；

3、基于切面（AOP）和惯例进行声明式编程；

4、通过切面和模版减少样式代码；



### 1.3、什么是SpringBoot

学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤； 后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；不知道你们有没经历过框架不断的演进，然后自己开发项目所有的技术也再不断的变化、改造，反正我是都经历过了，哈哈。言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can "just run"，能迅速的开发web应用，几行代码开发一个http接口。

所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。

是的这就是Java企业级应用->J2EE->spring->springboot的过程。

随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；

Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，

简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。

Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。

**Spring Boot的主要优点：**

- 为所有Spring开发者更快的入门
- **开箱即用**，提供各种默认配置来简化项目配置
- 内嵌式容器简化Web项目
- 没有冗余代码生成和XML配置的要求', firstPicture='/images/avatar.jpg', flag='原创', views=76, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Sat Apr 01 21:30:43 CST 2017, updateTime=Sun Apr 02 22:13:27 CST 2017, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试1的说明'}, Blog{id=35, title='测试2', content='## 2、YAML语法：

### 1、基本语法

k:(**空格**)v：表示一对键值对 ==空格必须有==；

以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
    port: 8081
    path: /hello
# server:(空格)port:(空格)8081
```

属性和值也是大小写敏感；



### 2、值的写法

#### 2.1、字面量：普通的值（数字，字符串，布尔）

​	k:  v：字面直接来写；

​		字符串默认不用加上单引号或者双引号；

​		""：双引号；\n是转义字符；**特殊字符会作为本身想表示的意思**

​				name:   "zhangsan \n lisi"：输出；zhangsan 换行  lisi

​		''：单引号；\n就不是转义字符，**特殊字符最终只是一个普通的字符串数据**

​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi



#### 2.2、对象、Map（属性和值）（键值对）：

​	k: v：在下一行来写对象的属性和值的关系；注意缩进

​		对象还是k: v的方式

```yaml
friends:
		lastName: zhangsan
		age: 20
```

行内写法：

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 2.3、数组（List、Set）：

用- 值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



## 3、配置文件值注入

### 3.1、yaml方式注入

配置文件

```yaml
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12
```

javaBean：

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    ...set,get方法
```

**注意:javaBean一定要写set,get方法,这样才能注入值**

我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

', firstPicture='/images/avatar.jpg', flag='原创', views=11, appreciation=true, shareStatement=false, commentabled=false, published=true, recommend=true, createTime=Thu Apr 04 14:53:51 CST 2019, updateTime=Sun Apr 05 22:01:03 CST 2020, type=Type{id=6, typeName='SpringBoot', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='SpringBoot111111'}, Blog{id=36, title='mybatis测试', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=false, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sat Apr 04 20:15:07 CST 2020, updateTime=Sun Apr 05 23:20:12 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述'}, Blog{id=37, title='mybatis测试1', content='1. 什么是缓存 [ Cache ]？
   - 存在内存中的临时数据。
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率。
3. 什么样的数据能使用缓存？
   - 经常查询并且不经常改变的数据。

### Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 11.1、一级缓存

- 一级缓存也叫本地缓存：
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；

### 初体验测试

1. 在mybatis中加入日志，方便测试结果

2. 编写接口方法

   ```java
   //根据id查询用户
   User queryUserById(@Param("id") int id);
   ```

3. 接口对应的Mapper文件

   ```xml
   <select id="queryUserById" resultType="user">
       select * from user where id = #{id}
   </select>
   ```

4. 测试

   ```java
   @Test
   public void testQueryUserById(){
       SqlSession session = MybatisUtils.getSession();
       UserMapper mapper = session.getMapper(UserMapper.class);
   
       User user = mapper.queryUserById(1);
       System.out.println(user);
       User user2 = mapper.queryUserById(1);
       System.out.println(user2);
       System.out.println(user==user2);
   
       session.close();
   }
   ```

5. 结果分析
   ![1567088746852.png](C:\Users\hsj\AppData\Roaming\Typora\typora-user-images\a7fc0d8f1226c9cd610a96b0796abefe_4067844505.png)

### 一级缓存失效的四种情况

- 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；

- 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

  1. sqlSession不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         SqlSession session2 = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session2.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(1);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
         session2.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！结论：**每个sqlSession中的缓存相互独立**

  2. sqlSession相同，查询条件不同

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
         UserMapper mapper2 = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
         User user2 = mapper2.queryUserById(2);
         System.out.println(user2);
         System.out.println(user==user2);
     
         session.close();
     }
     ```

     观察结果：发现发送了两条SQL语句！很正常的理解，结论：**当前缓存中，不存在这个数据**

  3. sqlSession相同，两次查询之间执行了增删改操作！

     - 增加方法

       ```java
       //修改用户
       int updateUser(Map map);
       ```

     - 编写SQL

       ```xml
       <update id="updateUser" parameterType="map">
           update user set name = #{name} where id = #{id}
       </update>
       ```

     - 测试

       ```java
       @Test
       public void testQueryUserById(){
           SqlSession session = MybatisUtils.getSession();
           UserMapper mapper = session.getMapper(UserMapper.class);
       
           User user = mapper.queryUserById(1);
           System.out.println(user);
       
           HashMap map = new HashMap();
           map.put("name","kuangshen");
           map.put("id",4);
           mapper.updateUser(map);
       
           User user2 = mapper.queryUserById(1);
           System.out.println(user2);
       
           System.out.println(user==user2);
       
           session.close();
       }
       ```

       观察结果：查询在中间执行了增删改操作后，重新执行了，结论：**因为增删改操作可能会对当前数据产生影响**

  4. sqlSession相同，手动清除一级缓存

     ```java
     @Test
     public void testQueryUserById(){
         SqlSession session = MybatisUtils.getSession();
         UserMapper mapper = session.getMapper(UserMapper.class);
     
         User user = mapper.queryUserById(1);
         System.out.println(user);
     
         session.clearCache();//手动清除缓存
     
         User user2 = mapper.queryUserById(1);
         System.out.println(user2);
     
         System.out.println(user==user2);
     
         session.close();
     }
     ```

所以说，一级缓存类似一个map

', firstPicture='/images/avatar.jpg', flag='转载', views=5, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=Fri Apr 05 07:29:45 CST 2019, updateTime=Sun Apr 05 23:18:45 CST 2020, type=Type{id=7, typeName='Mybatis', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='mybatis描述22222222'}, Blog{id=38, title='测试测试测试', content='## 测试测试测试', firstPicture='/images/avatar.jpg', flag='原创', views=10, appreciation=true, shareStatement=true, commentabled=false, published=true, recommend=true, createTime=Sun Apr 05 22:01:28 CST 2020, updateTime=Sun Apr 05 22:29:57 CST 2020, type=Type{id=1, typeName='Java', blogs=[]}, user=User{id=1, nickname='BloothOfYouth', username='null', password='null', email='null', avatar='/images/avatar_meitu_1.jpg', type='null', createTime=null, updateTime=null, blogs=[]}, tags=[], comments=[], tagIds='null', description='测试测试测试'}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}, totalBlogsCount=5, topTypes=PageInfo{pageNum=1, pageSize=7, size=3, startRow=1, endRow=3, total=5, pages=1, list=Page{count=true, pageNum=1, pageSize=7, startRow=0, endRow=7, total=5, pages=1, reasonable=true, pageSizeZero=false}[Type{id=6, typeName='SpringBoot', blogs=[Blog{id=20, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=35, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=7, typeName='Mybatis', blogs=[Blog{id=36, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}, Blog{id=37, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}, Type{id=1, typeName='Java', blogs=[Blog{id=38, title='null', content='null', firstPicture='null', flag='null', views=null, appreciation=null, shareStatement=null, commentabled=null, published=null, recommend=null, createTime=null, updateTime=null, type=null, user=null, tags=[], comments=[], tagIds='null', description='null'}]}], prePage=0, nextPage=0, isFirstPage=true, isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=8, navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]}}
2020-04-08 20:26:17.745  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/35', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[35, org.apache.shiro.web.servlet.ShiroHttpServletRequest@4288aed7]}
2020-04-08 20:26:17.768  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 20:26:18.432  INFO 13224 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 20:26:18.436  INFO 13224 --- [http-nio-80-exec-4] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 20:26:40.200  INFO 13224 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[36, org.apache.shiro.web.servlet.ShiroHttpServletRequest@1a46ff8c]}
2020-04-08 20:26:40.225  INFO 13224 --- [http-nio-80-exec-10] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 20:26:41.131  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 20:26:41.135  INFO 13224 --- [http-nio-80-exec-8] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 20:27:37.204  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/37', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[37, org.apache.shiro.web.servlet.ShiroHttpServletRequest@2de46715]}
2020-04-08 20:27:37.225  INFO 13224 --- [http-nio-80-exec-6] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 20:27:38.056  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 20:27:38.058  INFO 13224 --- [http-nio-80-exec-3] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
2020-04-08 20:27:57.159  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/blog/38', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blog', args=[38, org.apache.shiro.web.servlet.ShiroHttpServletRequest@14516734]}
2020-04-08 20:27:57.184  INFO 13224 --- [http-nio-80-exec-9] com.hjf.blog.aspect.LogAspect            : Result : blog
2020-04-08 20:27:58.146  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Request : RequestLog{url='http://localhost/footer/blogs', ip='0:0:0:0:0:0:0:1', classMethod='com.hjf.blog.controller.indexController.blogs', args=[{}]}
2020-04-08 20:27:58.150  INFO 13224 --- [http-nio-80-exec-7] com.hjf.blog.aspect.LogAspect            : Result : _fragments :: newblogList
